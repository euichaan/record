# 락킹 기법과 데드락
## 락킹 기법
멀티스레드 애플리케이션을 제작할 때 `fine-grained` 락킹과 `coarse-grained` 락킹을 사용할 수 있다.  
다중 공유 리소스가 있다고 가정하면 모든 공유 리소스를 단일 락킹으로 제한하거나 각 리소스마다 개별 락킹으로 제한할 수 있다.  
  
coarse-grained 락킹 기법의 장점은 단일 락킹만 신경 쓰면 되는 것이다.  
공유 리소스에 액세스할 때 마다 해당 락킹만 사용하면 된다.  
이 기법은 유지하기가 쉬우므로 강력한 장점이 된다.  
그러나 다소 과한 조치가 될 수 있는데, 최악의 경우 한 번에 한 스레드만 프로세스가 진전된다는 것이다.  
모든 스레드가 공유 리스소에 액세스하는 경우가 이에 해당한다.  
  
대신 공유 리소스를 개별로 잠근다면 모든 리소스에 개별 락킹을 생성하는 것과 같고 이는 세밀한 락킹 기법으로(fine-grained) 작용해 병렬성은 키우고 경쟁은 낮춘다.  
하지만 여러 개의 개별 락킹 시 발생하는 문제는 `데드락`이다.  
  
## 데드락
데드락이란 모두가 움직이려고 하지만 다른 사람이 움직이기를 기다리느라 움직이지 못하는 상태와 같다.  
대부분 손보기가 어려운 순환 종속성을 띈다.  

데드락이 발생하는 조건은 다음과 같다.  
- Mutaul Exclusion: 한 번에 한 스레드만 단독으로 리소스에 액세스할 수 있다.  
- Hold and Wait: 최소 하나의 스레드가 리소스를 점유하며 다른 리소스에 대기한다.  
- Non-preemptive allocation: 스레드가 사용 완료할 때까지 리소스를 사용할 수 없다. 다시 말해 다른 스레드의 리소스를 뺏을 수 없다. 해당 스레드의 리소스 사용이 끝날 때까지 기다려야 한다.  
- Circular wait: 순환 대기  
  
데드락을 해결하는 확실한 솔루션은 네 가지 조건 중 하나라도 충족하지 않게 만드는 것이다.  
  
데드락을 예방하는 가장 간단한 방법은 마지막 조건인 순환 대기를 예방하는 것으로 **동일한 순서로 공유 리소스를 잠그고 모든 코드에 해당 순서를 유지**하면 된다.  
  
참고로 락킹을 해제하는 순서는 중요하지 않다.  
  
복잡한 애플리케이션의 경우 순서를 유지하는 것이 상당히 어렵기 때문에 **데드락을 감지하는 감시 장치를 사용한다.**  
Thread interruption, tryLock operation과 같은 방법이 있지만 synchronized로는 사용할 수 없다.
```text
락킹을 처리하기 전에 다른 스레드에서 락킹이 처리되었는지 확인해서 
스레드가 중단되는 것을 막을 수 있는데, 이를 tryLock이라고 한다.
```