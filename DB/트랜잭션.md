# 트랜잭션
트랜잭션은 `데이터의 정합성`을 보장하는 기능.
논리적인 작업을 모두 완벽하게 처리 or 처리 실패 시 모두 원 상태로 복구(rollback)해서 부분 업데이트를 방지하는 기능

여러 SQL문을 함께 그룹화해서 모든 구문이 성공하거나 성공하지 않도록 하는 장치(원자성 이라고 알려진 속성)  
  
저축 계좌 -> 예금 계좌로 500달러를 이체하려고 하는데, 저축 계좌에서는 돈이 성공적으로 인출되었지만 예금 계좌로 입금되지 않았다면 화가 날 것이다.  
이체 요청을 처리하는 프로그램은 먼저 트랜잭션을 시작한 다음 저축한 돈을 예금 계좌로 옮기는 데 필요한 SQL 문을 실행하며 모든 과정이 성공하면 `commit` 명령어를 실행해서 거래를 종료한다. 그러나 예상치 못한 일이 발생하면 프로그램은 `rollback` 명령어를 실행해서 트랜잭션이 시작된 이후의 모든 변경 사항을 취소한다.  
  
트랜잭션이 커밋되었는지 롤백되었는지에 관계없이 트랜잭션 실행 중에 획득한 모든 리소스(예를 들어 쓰기 잠금 등)는 트랜잭션이 완료될 때 해제된다.  
  
`commit` 또는 `rollback`이 실행되기 전에 서버가 종료되면 서버가 다시 온라인 상태가 될 때 트랜잭션이 롤백된다. (온라인 상태가 되기 전에 데이터베이서 서버가 완료해야 하는 작업 중 하나는 서버가 종료될 때 진행 중이던 불완전한 트랜잭션을 찾아서 롤백하는 것이다).  
  
또한, 프로그램이 트랜잭션을 완료하고 commit을 실행했지만 변경 사항이 영구 스토리지에 적용되기 전에 서버가 종료되는 경우(즉, 수정된 데이터가 메모리에 있지만 디스크에 플러시되지 않은 경우), 데이터베이스 서버는 서버가 다시 시작될 때 트랜잭션의 변경 사항을 다시 적용해야 한다. 이러한 속성을 지속성(durability)이라고 한다.  
  
MySQL은 명시적으로 트랜잭션을 시작하지 않는 한 개별 SQL 문은 서로 독립적으로 자동 커밋된다.  
`SET AUTOCOMMIT=0`을 통해 자동커밋 모드를 비활성화할 수 있다.  
자동커밋 모드를 비활성화하면 모든 SQL 구문이 트랜잭션 범위 내에서 실행되며 명시적으로 커밋되거나 롤백되어야 한다.  
  
다른 작업의 간접적인 결과로 또는 제어할 수 없는 어떤 이유로 트랜잭션이 종료될 수 있는 몇 가지 시나리오가 있다.  
  
1. 서버가 종료되고 서버가 재시작되면서 트랜잭션이 자동으로 `롤백`된다.  
2. alter table과 같은 SQL 스키마 문을 실행하면 현재 트랜잭션이 `커밋`되고 새로운 트랜잭션이 시작된다.  
3. 다른 start transaction 명령어를 실행하면 이전 트랜잭션이 `커밋`된다.  
4. 서버가 교착 상태(deadlock)를 감지했을 때 해당 트랜잭션이 원인이라고 판단되면 서버는 트랜잭션을 조기 종료한다. 이 경우 트랜잭션이 `롤백`되고 오류 메시지가 표시된다.  
  
두 번째와 네 번째 시나리오는 좀더 알아볼 필요가 있다.  
두 번째 시나리오의 경우, 새 테이블이나 인덱스 추가 또는 테이블에서 열 삭제와 같은 데이터베이스 변경은 롤백할 수 없으므로, 스키마를 변경하는 명령어는 트랜잭션 외부에서 수행해야 한다. 따라서 트랜잭션이 현재 진행중일 때 서버는 현재 트랜잭션을 커밋하고 SQL 스키마 문 명령을 실행한 다음 자동으로 세션에 대한 새 트랜잭션을 시작한다.  
  
네 번째 시나리오는 교착 상태 감지를 다룬다.  
교착 상태는 두 개의 서로 다른 트랜잭션이 다른 트랜잭션이 현재 보유하고 있는 리소스를 대기할 때 발생한다.  
일반적인 전략 중 하나는 거래 데이터를 삽입하기 전 계좌 데이터를 수정하는 것과 같이 데이터 리소스가 항상 동일한 순서로 접근하도록 하는 것이다.  

경우에 따라 트랜잭션 내에서 문제가 발생하여 전체를 롤백할 수도 있지만 실행한 모든 작업을 취소하지 않을 수도 있다. 이런 상황에서는 트랜잭션 내에 하나 이상의 세이브포인트를 설정하고, 이를 사용해서 트랜잭션 시작 시점으로 완전히 롤백하는 대신 트랜잭션 내의 특정 위치로 롤백할 수 있다.  
```sql
SAVEPOINT my_savepoint;

ROLLBACK TO SAVEPOINT my_savepoint;
```
## 잠금
```
📌
잠금은 동시성을 제어하기 위한 기능으로… (real mysql 8.0 중에서)
```  
  
잠금은 데이터베이스 서버가 데이터 자원의 동시 사용을 제어하는 데 사용하는 메커니즘이다.  
데이터베이스의 일부가 잠기면 해당 데이터를 수정하거나 읽으려는 다른 사용자는 잠금이 해제될 때까지 기다려야 한다. 대부분의 데이터베이스 서버는 다음 두 가지 잠금 방식 중 하나를 사용한다.  
  
### Lock Based Concurrency Control
데이터베이스 writer는 데이터를 수정하기 위해 쓰기 잠금(write lock)을 서버에 요청하고 수신해야 하며, 데이터베이스 reader는 데이터를 조회하기 위해 서버에 읽기 잠금(read lock)을 요청하고 수신해야 한다. 여러 사용자가 동시에 데이터를 읽을 수 있지만 각 테이블(또는 그 일부)에 대해 한 번에 하나의 쓰기 잠금만 제공하고 쓰기 잠금이 해제될 때까지는 읽기 요청이 차단된다.  
  
동시 읽기와 쓰기 요청이 많으면 대기 시간이 길어질 수 있다.  
    
### Multi-Version Concurrency Control
데이터베이스 writer는 데이터를 수정하기 위해 쓰기 잠금을 서버에 요청하고 수신해야 하지만, reader가 데이터를 조회할 때는 어떠한 유형의 잠금도 필요하지 않다. 대신 서버는 쿼리가 시작될 때부터 쿼리가 완료될 때까지 reader에게 데이터에 대한 일관된 보기를 제공한다(다른 사용자가 수정을 하더라도 데이터는 동일하게 보인다). 이 접근 방식을 버전관리(versioning)라고 한다.  
  
데이터를 수정하는 동안 오래 실행되는 쿼리가 있으면 문제가 될 수 있다.  
  
### 잠금 단위
- 테이블 잠금: 여러 사용자가 동일한 테이블의 데이터를 동시에 수정하지 못하도록 한다.  
- 페이지 잠금: 여러 사용자가 테이블의 동일한 페이지(한 페이지는 보통 2KB에서 16KB 범위의 메모리 세그먼트)의 데이터를 동시에 수정하지 못하도록 한다.  
- 행 잠금: 여러 사용자가 테이블에서 동일한 행을 동시에 수정하지 못하도록 한다.  
  
이번 주의 영화 대여 내역을 요약하는 보고서를 생성한다고 가정해보자. 보고서를 실행하는 동안에도 다음과 같은 작업이 발생한다.  
- 고객이 영화를 대여한다.  
- 고객이 반납일 이후 영화를 반납하고 연체료를 지불한다.  
- 5편의 새로운 영화가 재고에 추가된다.  
  
즉, 보고서가 실행되는 동안에도 여러 사용자가 데이터를 수정한다. 그렇다면 보고서에는 어떤 숫자가 표시되어야 할까?  
  
보고서 페이지에 나타나는 데이터는 보고서가 시작될 때의 데이터베이스 상태(서버에서 버전관리 방식을 사용하는 경우) 또는 서버가 보고서 애플리케이션에서 읽기 잠금을 실행할 때(서버가 읽기와 쓰기 잠금을 모두 사용하는 경우)의 데이터베이스 상태를 반영한다.  