# 데이터베이스 모델링
초기 요구 사항  
- 회원이 가입하고 자신의 정보를 관리할 수 있다.  
- 판매자는 상품을 등고하고 관리할 수 있다.  
- 회원은 상품을 주문할 수 있다.  
  
실무 개발에서 가장 중요한 것 - 데이터베이스 설계  
잘못된 설계는 결국 성능 저하, 데이터 불일치, 유지보수의 어려움이라는 기술 부채로 돌아온다. 결국 이 부채는 시간이 지날수록 눈덩이처럼 불어나 결국 시스템 전체를 마비시키는 원인이 된다.  
  
현대의 데이터베이스 설계 방법론 (유연한 설계)  
  
## 잘못된 설계가 부르는 재앙
모든 정보를 한곳에 관리하기 편할 것이라고 생각해서 `orders` 테이블 하나를 만들었다.  
orders 테이블  
- order_id  
- customer_id    
- customer_name  
- product_id  
- product_name  
...  
  
나쁜 설계의 3대 문제점  
- 데이터 무결성 훼손  
- 성능 저하  
- 유지보수 비용 증가  
  
진짜 문제는 이상 현상(Anomaly)에서 시작된다.  
고객이 이사를 가서 주소를 '서울시 강남구'에서 '제주시 애월읍'으로 변경해달라고 요청했다. 개발자는 `UPDATE` 쿼리를 실행해야 한다.  
```sql
UPDATE orders
SET customer_address = '제주시 애월읍'
WHERE customer_id = 'user1`;
```
그런데 개발자가 실수로 다음과 같이 쿼리를 작성했다면 어떻게 될까?  
```sql
UPDATE orders
SET customer_address = '제주시 애월읍'
WHERE order_id = 1005;
```
수정 이상. 하나의 정보를 바꾸기 위해 여러 데이터를 수정해야 하고, 그 과정에서 일부가 누락될 때 데이터 불일치가 발생하는 현상이다.  
  
삽입 이상  
```sql
INSERT INTO orders (customer_id, customer_name, customer_address)
VALUES ('user4', '션', '부산시 해운대구'); 
```
주문을 하지 않으면 고객 정보를 등록할 수 없는 모순이 발생한다.  
  
삭제 이상  
특정 정보를 삭제했을 뿐인데, 유지되어야 할 다른 중요한 정보까지 연쇄적으로 삭제되는 현상  
  
테이블이 뚱뚱해지고 길어져 있어 디스크에서 읽어야 할 데이터 양이 많아지니 당연히 속도는 느려진다.  
  
위에서 본 이상 현상을 피하기 위해 개발자들은 애플리케이션 레벨에서 방어 로직을 짜기 시작한다. 데이터베이스가 제 역할을 못하니, 그 부담이 고스란히 애플리케이션 코드로 전가되어 시스템 전체가 비대하고 복잡해지는 결과를 낳는다.  
  
## 설계의 3단계 - 개념, 논리, 물리
**1단계: 개념적 설계 (Conceptual Design)**    
목표: 비즈니스의 아이디어나 요구 사항을 이해하고, 현실 세계의 정보들을 컴퓨터 세상의 언어로 번역하기 위한 밑그림을 그리는 단계.  
핵심 질문: 우리가 다루어야 할 데이터는 무엇이며(Entity), 그 데이터들은 서로 어떤 관계(RelationShip)를 맺고 있는가?  
산출물: `ERD`  
    
**2단계: 논리적 설계 (Logical Design)**  
목표: 개념적 설계에서 만든 밑그림을, 데이터베이스 기술인 '관계형 데이터베이스'의 원리에 맞게 구체적인 구조로 다듬는 관계다. 특정 RDBMS(MySQL, Oracle 등)에 종속되지 않는, 순수한 논리적인 데이터 구조를 만든다.  
핵심 질문: 개념 모델의 각 요소들을 어떤 테이블(Table) 구조로 표현할 것인가? 데이터의 중복을 막고 관계를 명확히 하기 위해 어떤 규칙(정규화)를 적용해야 하는가?  
산출물: `정규화된 테이블 스키마`. 각 테이블이 어떤 컬럼(속성)들을 가질지, 기본 키(PK)와 외래 키(FK)는 무엇으로 할지 등을 명확하게 정의한다.    
**3단계: 물리적 설계 (Physical Design)**
목표: 논리적 설계에서 만든 테이블 스키마를, 실제 우리가 사용할 특정 RDBMS(이 강의에서는 MySQL)의 특성에 맞게 최적화하여 구현하는 마지막 단계.  
핵심 질문: 각 컬럼에 어떤 데이터 타입을 할당해야 가장 효율적일까? 어떤 컬럼에 인덱스를 설정해야 조회 속도가 빨라질까?  
산출물: `물리적인 테이블 정의서, SQL 스크립트`  
  
관계형 데이터베이스라는 용어에서 사용하는 관계(Relation)라는 뜻은 테이블 간의 관계가 아니라 사실은 테이블(릴레이션) 그 자체를 뜻하는 것이다.  
  
좋은 설계는 '비용'이 아니라 '투자'다. 초반에 들이는 설계 시간은 미래에 발생할 엄청난 재앙을 막고, 시스템의 수명을 늘리는 가장 현명한 투자다.  
  
배포가 진행된 후 테이블 설계를 바꾸는 것의 비용은 100보다 더 들어갈 수 있다. (마이그레이션 비용 포함)  
  
# 개념적 모델링
모든 설계는 요구 사항 분석에서 시작한다.  
1. 회원 기능  
2. 상품 기능  
3. 주문 기능  
  
요구 사항 속에 우리가 만들어야 할 데이터 세상의 모든 뼈대가 숨어있다. 이 뼈대를 찾아내는 아주 효과적인 방법이 있는데, 바로 '명사'와 '동사'에 집중하는 것이다.  
- 명사(Nouns): 우리가 관리해야 할 데이터의 대상, 즉 엔티티(Entity) 또는 그 엔티티가 가지는 속성(Attribute)이 될 확률이 높다.  
- 동사(Verbs): 데이터들 사이의 행위나 관계, 즉 관계(Relationship)가 될 확률이 높다.  
  
항상 제일 중요한 관점 - 우리의 궁극적인 목표가 무엇인가?  
  
엔티티. 저장할 가치가 있는 중요 데이터를 가지고 있으면서, 다른 것과 명확히 구별되는 대상. (회원, 상품, 주문 등)  
해당 엔티티에 소속된 세부 정보는 속성(Attribute)  
  
명사를 찾으라는 규칙의 진짜 의미는 시스템이 정보를 저장하고 관리해야 할 대상을 찾으라는 의미  
**행위(동사)와 행위의 기록(명사)을 구분하기**  
'주문하다'는 분명 동사이다. 하지만 우리가 모델링하는 것은 '주문하는 행위 그 자체'가 아니라, '주문이라는 행위가 발생한 결과로 남는 정보의 묶음, 즉 주문 기록'이다. (주문서)  
  
명사를 찾으라는 규칙의 실질적인 의미  
1. 우선 눈에 보이는 명사(고객, 상품 등)를 찾아 엔티티 후보로 삼는다.  
2. 다음으로, 중요한 동사(주문하다, 예약하다, 수강신청하다 등)를 찾는다.  
3. 그리고 그 동사가 **"관리해야 할 기록이나 증빙을 남기는가?"**라고 질문한다.  
4. 만약 그렇다면, 그 동사의 명사형(주문, 예약, 수강)을 새로운 엔티티로 만든다.  
  
회원 - 주문 - 상품  
  
엔티티는 "우리가 데이터를 저장하고 관리해야 할 대상"을 의미한다. 조금 더 구체적으로는 '저장할 만한 가치가 있는 정보를 여러 개 가지고 있으면서, 다른 것과 명확히 구분되는 유무형의 모든 것'  
  
엔티티인가 속성인가 헷갈릴 때는 **이것이 우리 비즈니스에서 독립적으로 관리되어야 할 정보 덩어리인가?**  
회원 주소 - 독립적인 정보 덩어리가 아니라 회원이라는 더 큰 정보 덩어리에 속한 일부.  
주문 - 자신만의 여러 정보를 가지는 독립적인 정보 덩어리  
  
기본 엔티티(회원, 상품): 데이터 변경이 잦지 않고, 주로 조회(READ) 작업이 많다. 따라서 조회 성능에 최적화된 인덱싱 전략이 중요하다.  
중심 엔티티(주문): 조회의 중심축이자 트랜잭션의 핵심이다. 데이터는 꾸준히 증가하며, 조회(SELECT)뿐만 아니라 주문 상태 변경(UPDATE)도 빈번하게 일어난다. 예를 들어, 주문 테이블은 사용자가 '내 주문 목록(회원 id 기준)'을 볼 때, 관리자가 '오늘의 주문(주문 일시 기준)'을 확인할 때, '배송 준비 중(주문상태 기준)'인 주문을 찾을 때 등 여러 방식으로 조회된다. 따라서 회원 id, 주문 일시, 주문상태 같은 컬럼에는 각각의 쓰임새에 맞는 인덱스를 생성하는 것이 성능 유지의 관건이다.  
행위 엔티티(주문 이력, 결제 내역): 하나의 주문을 할 때 결제 방식을 신용카드, 포인트, 쿠폰 3가지를 사용해서 결제했다고 가정하면 주문은 하나의 행이 만들어지지만, 결제 내역은 3개의 행이 만들어진다. (Heavy INSERT). 따라서 설계 초기부터 데이터 파티셔닝이나 주기적인 아카이빙 전략을 고민해야 한다. 이런 테이블을 주문일 기준으로 월별 또는 분기별로 분할해두면, 특정 기간의 데이터 조회나 삭제 시 성능 저하를 막을 수 있다. 이런 고민 없이 테이블을 하나로만 운영하면, 몇 년 뒤 데이터가 수억 건 쌓였을 때 시스템 전체가 느려지는 재앙을 맞게 된다.  
  
약한 엔티티는 다른 엔티티('소유 엔티티' 또는 '식별 엔티티'라 부르는 강한 엔티티)가 존재하지 않으면 독립적으로 존재할 수 없는, 존재 종속적인 엔티티.  
식별자 구성: 전통적인 방식에서 약한 엔티티는 자신을 식별하기 위해 소유 엔티티의 주식별자를 빌려와 자신의 속성(부분키)와 결합하여 주식별자로 삼는다. 예를 들어 부모의 기본 키(employee_id)를 가져와 자식의 속성(name)과 합쳐 복합 기본 키(Composite Primary Key) (employee_id, name)를 만든다. 예시: 부양가족  
  
부모 엔티티(사원) 정보가 없는 자식 데이터(부양가족), 즉 고아 데이터(Orphaned Data)가 생겨나면 데이터베이스의 정합성(Integrity)이 깨진다. 약한 엔티티는 저장할 때 부모의 식별자를 반드시 함께 포함해서 저장해야 한다. 따라서 부모가 존재하지 않는 문제를 설계 단계에서 원천 차단할 수 있다.  
  
전통적인 설계 방식에서 약한 엔티티는 소유 엔티티의 주식별자를 빌려와 자신의 속성(부분키)과 결합해서 복합 기본 키를 만드는 방식을 사용한다. 하지만 이런 전통적인 방식은 최근에는 잘 사용하지 않고, 대신에 더 유연하고 실용적인 비식별 관계라는 방법을 주로 사용한다.  
