# 데이터베이스 모델링
초기 요구 사항  
- 회원이 가입하고 자신의 정보를 관리할 수 있다.  
- 판매자는 상품을 등고하고 관리할 수 있다.  
- 회원은 상품을 주문할 수 있다.  
  
실무 개발에서 가장 중요한 것 - 데이터베이스 설계  
잘못된 설계는 결국 성능 저하, 데이터 불일치, 유지보수의 어려움이라는 기술 부채로 돌아온다. 결국 이 부채는 시간이 지날수록 눈덩이처럼 불어나 결국 시스템 전체를 마비시키는 원인이 된다.  
  
현대의 데이터베이스 설계 방법론 (유연한 설계)  
  
## 잘못된 설계가 부르는 재앙
모든 정보를 한곳에 관리하기 편할 것이라고 생각해서 `orders` 테이블 하나를 만들었다.  
orders 테이블  
- order_id  
- customer_id    
- customer_name  
- product_id  
- product_name  
...  
  
나쁜 설계의 3대 문제점  
- 데이터 무결성 훼손  
- 성능 저하  
- 유지보수 비용 증가  
  
진짜 문제는 이상 현상(Anomaly)에서 시작된다.  
고객이 이사를 가서 주소를 '서울시 강남구'에서 '제주시 애월읍'으로 변경해달라고 요청했다. 개발자는 `UPDATE` 쿼리를 실행해야 한다.  
```sql
UPDATE orders
SET customer_address = '제주시 애월읍'
WHERE customer_id = 'user1`;
```
그런데 개발자가 실수로 다음과 같이 쿼리를 작성했다면 어떻게 될까?  
```sql
UPDATE orders
SET customer_address = '제주시 애월읍'
WHERE order_id = 1005;
```
수정 이상. 하나의 정보를 바꾸기 위해 여러 데이터를 수정해야 하고, 그 과정에서 일부가 누락될 때 데이터 불일치가 발생하는 현상이다.  
  
삽입 이상  
```sql
INSERT INTO orders (customer_id, customer_name, customer_address)
VALUES ('user4', '션', '부산시 해운대구'); 
```
주문을 하지 않으면 고객 정보를 등록할 수 없는 모순이 발생한다.  
  
삭제 이상  
특정 정보를 삭제했을 뿐인데, 유지되어야 할 다른 중요한 정보까지 연쇄적으로 삭제되는 현상  
  
테이블이 뚱뚱해지고 길어져 있어 디스크에서 읽어야 할 데이터 양이 많아지니 당연히 속도는 느려진다.  
  
위에서 본 이상 현상을 피하기 위해 개발자들은 애플리케이션 레벨에서 방어 로직을 짜기 시작한다. 데이터베이스가 제 역할을 못하니, 그 부담이 고스란히 애플리케이션 코드로 전가되어 시스템 전체가 비대하고 복잡해지는 결과를 낳는다.  
  
## 설계의 3단계 - 개념, 논리, 물리
개념적 설계 (Conceptual Design)  
누구나 이해할 수 있는 언어로(디자이너, PM ...) 설명하는 것이 핵심  

  
논리적 설계 (Logical Design)  
  
물리적 설계 (Physical Design)  
  
관계형 데이터베이스라는 용어에서 사용하는 관계(Relation)라는 뜻은 테이블 간의 관계가 아니라 사실은 테이블(릴레이션) 그 자체를 뜻하는 것이다.  
  
좋은 설계는 '비용'이 아니라 '투자'다. 초반에 들이는 설계 시간은 미래에 발생할 엄청난 재앙을 막고, 시스템의 수명을 늘리는 가장 현명한 투자다.  
  
배포가 진행된 후 테이블 설계를 바꾸는 것의 비용은 100보다 더 들어갈 수 있다. (마이그레이션 비용 포함)  
