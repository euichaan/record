# 서비스 개발자를 위한 컨테이너 뽀개기
[서비스 개발자를 위한 컨테이너 뽀개기](https://tech.kakaoenterprise.com/150)  
  
컨테이너는 **호스트 OS(커널)**을 사용하기 때문에 성능 저하가 크지 않다. 생산성 측면에서도 프로그램 실행에 필요한 모든 것을 하나로 **패키징**이 가능하고, 서버 환경으로부터 프로세스를 **격리**하여 실행할 수 있다. 또, 여러 컨테이너 간 **자원 경합**이 발생하지 않도록 리소스 설정이 가능하다.  
  
## 클라우드
공유 구성이 가능한 컴퓨팅 리소스(네트워크, 서버, 스토리지, 애플리케이션)의 통합으로 어디서나 간편하게, 요청에 따라 네트워크를 통해 언제든 접근하는 것을 가능하게 하는 모델이다. 이는 최소한의 이용 절차 또는 서비스 공급자의 상호 작용을 통해, 신속히 할당되어 제공된다.  

## 가상화
**실제가 아닌 하드웨어 환경**을 의미한다. 가상화는 가짜 하드웨어 환경을 만들어 내는 기술로, 실제 물리장비인 호스트와 가상머신인 게스트를 구분한다.  
- 호스트(Host): 가상화 소프트웨어(하이퍼바이저)를 구동하는 물리 시스템  
- 게스트(Guest): 하이퍼바이저(Hipervisor) 위에 설치되는 가상머신(Virtual Machine)  
  
### 하이퍼바이저(소프트웨어) 가상화
하이퍼바이저는 한 대의 머신에서 다수의 운영체제를 동시에 실행하는 소프트웨어로, 하드웨어를 가상화한다.  

### 컨테이너(애플리케이션) 가상화
컨테이너는 애플리케이션 구동에 필요한 모든 것들을 패키징하고 격리된 환경에서 실행한다. "컨테이너" 기반의 가상화로 애플리케이션 실행환경을 가상화한다. "패키징"과 "격리된 실행"이라는 특징 때문에 서버별 환경에 영향받지 않고 사람의 개입 없이 자동으로 배포할 수 있다.  

### 네트워크 가상화
네트워크의 한정된 물리주소라는 제약을 해결하고, 물리 IP 사용으로 인한 여러 의존성 구성을 가상 네트워크를 통해 추상화하여 단순하고 유연하게 할 수 있다.

## API
API(Application Programming Interface)는 가상화를 통해 가능해진 하드웨어와 애플리케이션 제공을 "추상화(인터페이스)"하는 레이어이다. 추상화를 하는 목적은 인터페이스(Interface)를 정의함으로써 리소스의 요청 및 제어 방법을 표준화하고, 이를 기준으로 리소스 딜리버리를 위한 인프라 체계를 정의하기 위함이다. 추상화는 세부 구현을 가림으로써 합의된 인터페이스 범주 내에서 다양한 구현이 가능하고, 필요에 따라 교체하여 사용할 수 있다. API는 명세로 랩핑 되는데, 다양한 리소스에 연결된 API들이 명세 안에서 목적에 맞게 구성된다. 명세는 오픈스택, 쿠버네티스 등 오케스트레이션 도구 위에서 컨트롤러들을 부리기 위한 일종의 작업 지시서로, 컴퓨팅 리소스 할당, 가상 네트워크 구성, 컨테이너 배치, 오토스케일링 등 다양한 작업을 자동화한다.

## 컨테이너
**컨테이너란 격리된 환경과 제한된 리소스로 제어되는 프로세스를 의미한다.**  
```text
컨테이너는 다세대 주택 안에 독립적으로 마련된 공간과 같다. 즉, 애플리케이션이 다른 프로세스의 영향을 받지 않게 격리하고 주어진 리소스 안에서 실행될 수 있게 해준다.
```
컨테이너는 프로세스 간 서로를 격리시키고 각자 필요한 환경을 꾸려서 실행하는 방법인 다세대주택의 방식으로 해결한다.  
그리고 공유 자원(cpu, memory, network)에 대해서 프로세스별로 할당치 만큼만 사용하도록 제한함으로써 누군가 자원을 과도하게 소비하여 피해를 주는 일이 없도록 한다.  
  
컨테이너는 실행파일뿐만 아니라 의존성 라이브러리, 설정 등 실행에 필요한 모든 것들을 "이미지"라고 하는 것에 모아 패키징함으로써 이 "이미지"만으로 서버 환경에 의존하지 않고 실행되는 것을 보장한다.  

## VM vs 컨테이너
VM은 컨테이너보다 훨씬 강력한 격리를 제공한다. "하이퍼바이저" 라는 소프트웨어가 하드웨어 리소스를 가상화하고, 그 위에 별도의 운영체제가 설치된다. 이 운영체제는 서버의 "호스트OS"와 구분해서 "게스트OS(GuestOS)"라고 부른다. 하이퍼바이저는 서버 위에 여러 종류의 GuestOS를 VM으로 실행할 수 있다.  

**이처럼 VM은 서버 안에 또 다른 서버가 있는 것처럼 별도의 OS 환경으로 동작한다.** 부팅과정도 있고, 여러 프로그램을 설치하여 사용하는 방식이 일반적인 물리 서버를 사용하는 것과 동일하다. 반면, 컨테이너는 (GuestOS) 없이 호스트 OS를 사용하고 프로세스를 격리하여 실행하는 방식으로 VM과는 매우 다르다.  
  
원래 컨테이너는 **리눅스 커널에서 지원하는 기능들로 만들어지기**에 윈도우, 맥 등 다른 OS에서는 동작하지 않는다. 이에 비해 VM은 다양한 종류의 OS를 설치하고 구동할 수 있다. 그렇다면 Mac이나 윈도우에서도 컨테이너 사용한 것은 어찌 된 것일까? 윈도우나 Mac에서 컨테이너 지원을 위해 리눅스 VM을 올리고 그 위에서 컨테이너를 가동하기 때문이다.
  
근래에는 컨테이너의 개념이 "리눅스 컨테이너"에 국한되기보다는 격리된 환경의 관점에서 경량 VM까지 아울러서 좀 더 폭넓게 해석되는 경향이 있다.  
  
컨테이너는 VM에 비해 작고 빠르다. 컨테이너는 호스트 커널에서 바로 처리되고 하드웨어를 직접 관리하는 반면에 VM은 GuestOS가 하드웨어 사용 시 하이퍼바이저의 처리를 기다려야 한다. 하이퍼바이저는 여러 GuestOS를 상대해여 하고, 하드웨어는 한정된 자원이다 보니 개별 GuestOS의 사정에 맞춰서 리소스를 제공하기 쉽지 않다. 이런 이유로 컨테이너와 VM의 성능 차이가 발생할 수 밖에 없긴 하다.  
  
AWS, GCP 등 퍼블릭 클라우드 환경에서는 실제로 VM 기반으로 인프라를 구성하고 그 위에서 컨테이너 형태로 애플리케이션을 구성해 다양한 IT 리소스를 명세와 API 기반으로 자동화하여 제공하고 있다.  
  
## 쿠버네티스
컨테이너 "오케스트레이션" 플랫폼. 컨테이너에 필요한 설정과 관리, 적절한 노드로 배치, 모니터링 등을 제공.  
  
쿠버네티스는 사용자의 명세를 기반으로 컨테이너의 스펙에 적합한 노드를 자동으로 선정한다. 전 세계 서버들을 컨테이너의 스펙과 비교하여 필터링하고 추려진 노드들을 스코어링하여 가장 최적인 노드로 컨테이너를 배치한다. 개발자는 노드가 어떤 서버에 배치되었는지 몰라도 된다. 쿠버네티스가 노드 선정과 배포를 더 간단하게 할 수 있었던 것은 컨테이너가 실행환경을 포함하고 있고 서버에 따라 영향을 받지 않기 때문이다.  
  
쿠버네티스는 명세를 기반으로 다양한 컨트롤러가 협력하는 방식으로 동작한다.  