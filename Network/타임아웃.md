# 타임아웃
외부 서비스 장애로 인해 응답이 오래 걸린다고 했을 때 외부 API 응답으로 대기하는 자원들이 운영 서버 내부에 쌓이면서 성능에 악영향을 줄 수 있다. 이를 해결하기 위한 가장 기본적인 방법은 타임아웃을 설정하는 것이다.  
크게 타임아웃에는 커넥션 타임아웃, 리드 타임아웃, HTTP 커넥션 풀 타임아웃을 설정해 볼 수 있다.  
  
# Connection Timeout과 Read Timeout의 의미
**Connection Timeout은 종단 간 연결하는데 소요되는 최대 시간을 의미한다.** 이 시간을 넘기게 되면 연결 할 수 없는 것으로 판단하고 에러가 발생한다. Connection 이라는 단어가 의미하는 것처럼 종단 간 연결에 사용되는 타임아웃이다. 그리고 이 때의 연결이란 `TCP 3 way handshake`를 통해 TCP 연결이 생성되는 것을 의미한다.  
  
**Read Timeout은 연결된 종단 간에 데이터를 주고 받을 때 소요되는 최대 시간을 의미한다.** 이 시간을 넘기게 되면 데이터를 받을 수 없는 것으로 판단하고 에러가 발생한다.  
  
Rest API 클라이언트의 경우라면 TCP 통신 과정에서 Connection Timeout과 Read Timeout이 적용되는 구간은 아래 그림과 같다.  
<img width="640" alt="timeout의 적용 구간" src="https://github.com/user-attachments/assets/3642eb08-c7e1-4e79-bd80-31660745b0fd">  
  
# 타임아웃 설정을 위한 기준 정하기
타임아웃 값을 설정하기에 앞서 기준을 정해야 한다. 그리고 그 기준은 아래 두 가지 조건을 만족 시키도록 설정 될 수 있다.  
- 네트워크 상에서 패킷 유실은 꼭 장애 상황이 아니라도 언제든 발생할 수 있다.  
- 네트워크 상에서 문제가 발생했다면 가능한 빨리 인지해야 한다.  
  
위 두 가지 조건을 바탕으로 적당한 값을 찾아야 한다.  
  
패킷 유실이라는 것은 언제든 발생할 수 있다는 것을 유념해 두어야 한다. 네트워크는 항상 100% 완벽하게 동작하지 않기 때문에 이를 고려해야 한다. 또한 실제로 네트워크 장애가 발생 했다면 가급적 빨리 발견해서 필요한 조치를 할 수 있어야 한다.  
  
만약 타임아웃 값을 너무 짧게 둔다면 간헐적으로 발생할 수 있는 패킷 유실에 대해 너무 민감하게 반응하게 되고, 타임아웃 값을 너무 길게 준다면 네트워크 장애를 발견하는데 긴 시간이 소요되게 된다.  
  
여기서는 "한 번의 패킷 유실 정도는 재전송을 통해 해결 할 수 있는 수준의 타임아웃" 을 기준으로 잡고 타임아웃 값을 설정해 보자.  
  
# Connection Timeout 값 설정하기
Connection Timeout 에서 발생할 수 있는 패킷 유실에 대해 생각해 봐야 한다. 고려해 볼 수 있는 경우의 수는 세 가지이다.  
1. SYN 패킷이 유실 되었을 때  
2. SYN + ACK 패킷이 유실 되었을 때  
3. 마지막 ACK 패킷이 유실 되었을 때  
  
SYN 패킷이 유실 되었을 때 부터 살펴보자.  
<img width="640" alt="syn 유실" src="https://github.com/user-attachments/assets/1156aff9-af37-412b-ab1d-75d78a10d186">  
A가 B와 연결을 맺기 위해 보낸 SYN 패킷이 유실되었다고 가정해보자.    
  
A는 B로부터 SYN + ACK를 받을 준비를 하고 있는데 SYN 패킷이 유실되어 B에게 도착하지 않았기 때문에 B는 SYN + ACK를 보낼 수 없다. 따라서 A는 자신이 보낸 SYN 패킷이 유실되었다고 판단하고 다시 보내게 된다. 그리고 이 때 사용되는 재전송을 판단하기 위한 타임아웃을 InitRTO 라고 부른다.  
  
패킷의 유실 여부를 판단하는 타임아웃 값을 RTO(Retransmission Timeout)라고 부르는 데 RTO는 두 종단 간의 RTT (Round Trip Time, 네트워크에서 패킷이 출발지에서 목적지로 전송된 후 다시 응답이 출발지로 돌아오기까지 걸리는 시간)을 기준으로 생성된다.  
    
두 종단 간에 패킷이 흐르는 데 100ms가 필요하다면, 보내는 데 100ms 받는데 100ms 합쳐서 200ms 가 소요되기 때문에 200ms 이상은 기다려야 패킷이 유실되었는지 여부를 알 수 있다. 하지만 방금 본 예제처럼 연결을 최초에 맺는 경우에는 종단 간 RTT 값을 알 수 없기 때문에 무조건 이만큼은 기다려보자 라는 설정 값이 필요하고 이 값이 바로 `InitRTO`이다. 그리고 이 값은 리눅스 상에서는 1초로 하드코딩 되어 있다. 따라서 SYN 패킷이 한 번 유실된다면 최소한 연결을 맺는데 1초 이상의 시간이 소요된다.    
     
다음으로 SYN + ACK 패킷이 유실 되었을 때를 생각해보자.  
<img width="640" alt="SYN + ACK 유실" src="https://github.com/user-attachments/assets/ff6ebec3-6121-44e0-8a3e-916e54cc6470">  
SYN 패킷이 B에게 정상적으로 도착했고, 이에 따라 B가 A에게 SYN + ACK 패킷을 전달했지만 중간에서 SYN + ACK 패킷이 유실되었다.  
SYN + ACK 패킷이 유실되었음을 알 수 없는 A는 당연히 SYN이 유실 되었다고 판단하고 1초 후에 다시 한 번 SYN을 보내게 된다. 그래서 원인은 다르지만 실질적으로 동작하는 방식은 SYN 패킷이 유실 되었을 때랑 동일하다.  
  
마지막으로 ACK 패킷이 유실되었을 때를 생각해보자.  
<img width="640" alt="ACK 유실" src="https://github.com/user-attachments/assets/bcf3565a-3771-43b2-a386-28bee64d2d43">  
ACK 패킷 유실의 경우는 앞의 두 경우와는 조금 다른데 왜냐하면 SYN과 SYN + ACK 패킷을 서로 주고 받으면서 A와 B는 둘 사이의 RTT를 알게 되었다. ACK 패킷부터는 InitRTO의 적용을 받지 않고 **RTT를 기반으로 계산된 RTO의 적용을 받는다.** 그리고 RTO의 기본값은 RTT를 기반으로 계산된 복잡한 값 혹은 이 값이 200ms보다 작다면 200ms가 적용된다. 따라서 ACK의 유실에 의한 재전송은 최소 200ms가 소요된다.  
  
InitRTO의 경우 2의 제곱값으로 값이 커지기 때문에 최초의 유실에 대해서는 1초를 기다리지만 두 번째 유실은 2초를 기다리게 된다. **즉 두 번 이상의 패킷 유실이 발생한다면 3초 이상의 지연 시간이 발생하기 때문에 Connection Timeout이 3초라면 최소한 패킷 유실이 두 번 이상 발생했을 수 있다는 이야기가 된다.** 이렇게 두 번 이상의 패킷 유실이 발생했다면 네트워크에 이슈가 있지 않은지 살펴봐야 할 필요가 있다.  
<img width="1040" alt="3초 이상 소요" src="https://github.com/user-attachments/assets/7afad579-d2c7-42a4-bb4e-77615b52dda4">
  
# Read Timeout 값 설정하기
Read Timeout은 패킷 재전송을 위한 타임아웃 값인 RTO가 RTT를 기준으로 만들어져서 보통 1초보다 짧다.  
  
RTO의 최소값은 200ms이기 때문에 Read Timeout 역시 한 번의 패킷 유실을 고려해서 200ms 보다는 크게 잡는다. 하지만 Read Timeout의 경우 고려해야 할 요소들이 있는데 바로 RTT와 요청을 받은 쪽에서 요청을 처리하기 위해 소요되는 프로세싱 타임이다.  
  
Read Timeout은 RTO 외에 프로세싱 시간까지 고려해서 설정해야 한다.  
  
---
RTO: RTO (Retransmission Timeout)은 TCP(Transmission Control Protocol)에서 송신한 데이터 패킷에 대한 ACK(응답)를 기다리는 시간의 한계치를 의미한다. 이 시간이 초과되면, TCP는 해당 패킷이 손실되었다고 판단하고 재전송(Retransmission)을 수행한다.  
  
---
출처  
https://alden-kang.tistory.com/20