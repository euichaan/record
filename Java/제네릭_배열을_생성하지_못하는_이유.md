# 제네릭 배열을 생성하지 못하는 이유
## 배열은 공변, 제네릭은 불공변
배열의 경우 Sub가 Super의 하위 타입일 때 Sub[]는 Super[]의 하위 타입이 된다. 이런 경우를 공변하다고 한다.  
반면 제네릭 타입의 경우 Sub가 Super의 하위 타입이라도 ArrayList<Sub>는 ArrayList<Super>의 하위 타입이 아니다. 이런 경우를 불공변하다고 한다.  
  
```java
Object[] objects = new String[1];
objects[0] = 1; // ArrayStoreException (RuntimeException) 발생
```
컴파일 타임에 Object[]이므로 Integer를 할당할 수 있으나, 런타임엔 String[]이기 때문에 ArrayStoreException이 발생한다.  
컴파일 타임에 타입 안정성을 보장해줄 수 없다.  
```java
ArrayList<Object> objectList = new ArrayList<String>(); // 불공변, 컴파일 불가.
```
  
## 제네릭 타입은 런타임에 소거
제네릭 타입은 런타임에 소거되므로 런타임에는 타입이 소거된 ArrayList만 남게 된다.
```java
// 컴파일 타임(실제 작성한 코드)
ArrayList<String> stringList = new ArrayList<String>();
ArrayList<Integer> integerList = new ArrayList<Integer>();

// 런타임(제네릭 타입은 런타임에 소거되므로 구분이 불가능하다)
ArrayList stringList = new ArrayList();
ArrayList integerList = new ArrayList();
```
    
## 제네릭 배열이 가능하다면 발생할 수 있는 문제점
```java
// 실제론 컴파일 에러가 발생한다.
ArrayList<String>[] stringLists = new ArrayList<String>[1]; // 제네릭 배열을 생성. 런타임시에는 제네릭 타입은 소거되므로 ArrayList[]가 된다.

ArrayList<Integer> intList = Arrays.asList(1);              // 타입 소거로 인해 런타임시 ArrayList가 된다.
Object[] objects = stringLists;                             // 배열은 공변성을 가지므로 Object[]는 ArrayList[]가 될 수 있다.
objects[0] = intList;                                       // intList또한 ArrayList이므로 배열의 요소가 될 수 있다. 
String s = stringLists[0].get(0)                            // String 타입을 가져야 하지만 Integer이므로 예외 발생  
```
만약 제네릭 배열을 만들 수 있다면 위와 같은 상황이 발생할 수 있고 이는 결국 런타임 예외로 이어진다.  

## 왜 제네릭 배열을 생성할 수 없을까
- 자바에서 제네릭 타입을 굳이 런타임에 소거한 이유는 하위 호환성을 보장하기 위함  
- 배열은 위에서 보았듯이 공변하므로 제네릭 배열이 가능하도록 하면 타입 안전성을 보장할 수 없게 되어 제네릭 배열을 직접 생성할 수 없다.  
  
제네릭은 런타임에 타입 정보가 없고, 배열은 공변이라는 성질으로 인해 상위 타입에 할당이 가능하다.  
따라서 이 둘이 만나면 타입 안정성이 완전히 깨진다. 따라서 Java는 아예 제네릭 배열 생성을 컴파일 에러로 막는다.  
  
## 제네릭 배열 사용하기
제네릭 배열을 직접 생성할 순 없지만 와일드카드 타입을 이용하거나, 강제 형변환을 통해 제네릭 배열을 사용할 수 있다.  
  
```java
List<?>[] lists = new List<?>[3];
lists[0] = Arrays.asList(1);
lists[1] = Arrays.asList("A");
// lists[2].add("C"); 컴파일 에러
for (final List<?> list : lists) {
    System.out.println(list);
}
```

```java
public class Store<E> {
    private E[] elements;
    private int index;
    
    // 경고가 발생하나 타입 안전성을 확신할 수 있으니 경고를 제거한다.
    @SuppressWarnings("unchecked")
    public Store(int size) {
     // this.elements = new E[size]; 직접 제네릭 배열은 생성불가!
        this.elements = (E[]) new Object[size]; // 강제 형변환을 이용하여 생성
        this.index = 0;
    }
```
