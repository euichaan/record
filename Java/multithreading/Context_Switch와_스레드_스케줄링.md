#  운영 체제 기초
# Context Switch
애플리케이션 각각의 인스턴스는 다른 프로세스와는 독립적으로 실행된다. 일반적으로 코어보다 프로세스가 훨씬 많고 각각의 프로세스는 하나 이상의 스레드를 가진다. 그리고 모든 스레드는 CPU 실행을 두고 서로 경쟁한다. 코어가 여러 개라 하더라도 스레드가 코어보다 많다. 그래서 운영 체제는 스레드 하나를 실행하고, 멈추고 다른 스레드 하나를 실행하고, 멈추고를 반복한다.  
  
하나의 스레드 실행을 멈추고 다른 스레드를 스케줄링한 다음 다시 실행하는 것이 바로 컨텍스트 스위치이다.  
동시에 많은 스레드를 다룰 때는 효율성이 떨어진다. 다른 스레드로 전환할 때는 기존의 모든 데이터를 저장하고 또 다른 스레드의 리소스를 CPU와 메모리에 복원해야 한다.  
너무 많은 스레드를 가동하게 되면 'Thrashing'이 발생한다는 것을 알아둬야 한다. 컨텍스트 스위치에 더 많은 시간을 할애하게 된다.  
```text
과도한 페이징 작업을 스래싱(Thrashing)이라고 부른다. 어떤 프로세스가 실제 실행보다 더 많은 시간을 페이징에 사용하고 있으면 스래싱이 발생했다고 한다. 예상대로, 스래싱은 심각한 성능 문제를 야기한다.
```
스레드는 공유하는 리소스가 많기 때문에 프로세스보다 리소스를 덜 사용한다. 즉, 같은 프로세스에 속한 두 스레드 간의 컨텍스트 스위치가 각각 다른 프로세스의 두 스레드 간의 컨텍스트 스위치보다 효율적이다.
## Thread Scheduling
운영체제가 어떤 스레드를 실행할지 언제 컨텍스트 스위치를 할지 결정하는 방법을 알아보자.  
  
텍스트 편집을 하면서 음악을 듣는다고 생각해보자. 프로세스는 텍스트 에디터와 뮤직 플레이어가 있다.  
작업의 도착 순서(Arrival Order)와 실행 시간(Length)가 주어진다고 가정하면 운영 체제는 누구를 가장 먼저 실행할까?  
  
단순하게 선착순으로 짠다면, 실행 시간이 긴 스레드가 먼저 도착하면 다른 스레드에 '기아 현상'이 발생한다는 것이다.  
특히 UI 스레드 입장서는 응답성을 방해해 최악의 사용자 경험을 야기할 것이다.  
  
그렇다면 짧은 순서로 스케줄링 해볼까?  
가장 짧은 작업을 항상 맨 앞에 배치하게 되면 계산이 들어간 긴 작업들은 영원히 실행될 수 없을지도 모른다.
  
일반적인 운영 체제에서는 '에포크'에 맞춰 시간을 적당한 크기로 나눈다. 그리고 스레드의 타임 슬라이스를 종류별로 에포크에 할당한다. 하지만 모든 스레드가 각 에포크에서 실행되거나 완료되지는 않는다.  
  
스레드에 시간을 할당하는 방법은 운영체제가 각각의 스레드에 적용하는 동적 우선순위에 달렸다.  
`Dynamic Priority = Static Priority + Bonus`  
정적 우선순위는 개발자가 미리 설정하고 보너스는 운영 체제가 각각의 에포크마다 조정한다.  
## Threads vs Processes
멀티 스레드 접근법과 멀티 프로세스 접근법 중에서 선택해야 한다.
스레드는 많은 리소스를 공유한다. 많은 데이터를 공유하는 다양한 작업을 실행하려면 멀티 스레드 애플리케이션 아키텍처가 좋을 것이다.  
스레드는 생성과 삭제가 훨씬 빠르고 같은 프로세스 안에서 멀티 스레드끼리 전환하는 것이 여러 프로세스 사이에서 전환하는 것보다 빠르다.  
  
하지만 독립된 프로그램을 독립된 프로세스에 실행하는 게 좋을 수도 있다. (보안, 안정성)  
또한, 서로 관련이 없는 작업을 실행하는 경우 같은 프로세스에 통합하는 것은 의미가 없다.  