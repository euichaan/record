# 스레드 성능
Latency: **지연 시간은 시간 단위로 측정되고 작업 하나의 완료 시간으로 정의된다.**    
Throughput: **일정 시간 동안 완료한 작업의 양으로 시간 단위당 작업으로 측정된다.**    
  
## Latency
멀티스레드 프로그래밍에서 지연 시간을 어떻게 줄일까?  
싱글 스레드로 T의 지연 시간이 걸리는 작업이 있다. 작업을 N개의 하위 작업으로 나눈 후 각각 다른 스레드에 할당하면 지연 시간을 T/N으로 줄일 수 있다.(N = 하위 작업의 개수)  
  
이런 이론적인 목표를 달성하려면 몇 가지 질문에 답이 필요하다.  
- N이 뭘까? 하위 작업을 원하는 개수로 나눌 수 있다면 몇 개가 될까?  
- 원래 작업을 분할하고 하위 작업을 스케줄링해 나중에 합치는 것에는 대가가 없을까?  
- 어떤 작업이든 원하는 만큼 하위 작업으로 나눌 수 있을까?  
  
일반적으로 N은 컴퓨터의 코어 개수와 최대한 비슷해야 한다. 그 이유는 하위 작업을 모두 병렬로 실행하면 지연 시간이 줄어들기 때문이다. 하위 작업은 다른 코어에서 실행하는 경우에만 완전히 병렬로 실행할 수 있다.  
하나의 스레드만 추가해도 생산성이 떨어져 성능도 저하되고 지연 시간은 늘어나게 된다. 추가된 스레드는 다른 스레드를 코어에서 앞뒤로 밀어내서 컨텍스트 스위치, 캐시 성능 저하, 추가 메모리 소비가 증가한다.  
  
정리하자면,  
스레드 개수와 코어 개수가 같다는 공식은 모든 스레드가 인터럽트 없이 하위 작업을 실행해야 최적이다. 다시 말해, 모든 스레드가 Runnable 상태여야 한다.  
시스템에서 CPU를 많이 소모하는 것은 실행되고 있지 않아야 한다.  
요즘 컴퓨터들은 코어 하나가 스레드 두 개를 동시에 실행할 수 있는 하이퍼스레딩을 사용한다. 물리적인 코어의 하드웨어 유닛 일부를 복제하여 두 스레드가 병행으로 실행되고 하드웨어 유닛 일부가 공유된다. 따라서 모든 스레드를 100% 병렬로 실행할 수는 없다.  
  
하나의 작업을 여러 작업으로 나누고 결과를 종합하는 데 드는 비용에 대해 살펴보자.  
1. 하나의 작업을 여러 작업으로 나누는 비용  
2. 스레드 생성 비용, 스레드에 작업을 전달하고 시작하는 비용  
3. 운영체제가 스레드를 실제로 스케줄링해 스레드가 실행되기까지의 시간  
4. 마지막 스레드가 완료되고 집계를 마쳤다는 신호를 기다리는 시간  
5. 통합 스레드가 신호를 받아 재실행될 때 까지 걸리는 시간  
6. 하위 작업을 하나의 아티팩트로 통합하는 비용  
  
기존 작업이 길고 무거울수록 작업을 분할해 병렬로 실행할 가치가 있다. 작고 사소한 작업이라면 굳이 분할하고 병렬로 실행할 가치가 없다.  
  
모든 작업을 여러 개별 작업으로 나누고 병렬로 실행할 수 있는 것은 아니다.  
  
## Throughput
처리량은 **주어진 기간에 완성되는 작업의 수**를 말한다. 시간 단위, 특히 초 단위로 작업을 나눠 처리량을 측정한다.  
  
애플리케이션의 처리량 개선 방법 관련 접근법을 몇 개 살펴보자.  
1. Breaking Tasks into Subtasks  
만약 작업을 완수하는데 T시간이 걸리면 이룰 수 있는 최소 처리량은 하나이거나 1을 T로 나눈 값이 된다.  
`Throughput = 1/T(Latency)`  
  
작업을 서브태스크로 나눈다면 각 서브태스크를 T/N에 끝낼 수 있다. 서브태스크를 나란히 수행하면 T/N의 throughput을 얻게 된다. 그러나 서브태스크로 작업을 나누더라도 T/N보다 낮은 처리량을 얻을 확률이 높다.  
  
2. Running Tasks in Parallel  
각 작업을 별개 스레드에 스케줄링하는 방법이 있다. 이 경우에도 이론적으로 최대 처리량은 N/T가 된다.  
각 작업의 수행 지연 시간을 줄이려 노력해 앞서 이론적인 처리량을 얻을 확률이 높다.  
작업이 내부적으로 연관되지 않고 별개이기 때문이다. 따라서 각 작업을 작은 작업으로 나눠야 하는 전처리 필요성을 없앨 수 있다. 다른 작업의 완료를 위해 그 작업이 끝나길 기다리지 않아도 된다.  
  
이 기술 중 하나인 스레드 풀링을 살펴보자.  
  
스레드 풀링은 스레드를 생성하고 미래 작업을 위해 다시 스레드를 사용할 뿐이다. 매번 처음부터 다시 스레드 생성하지 않는다. 스레드가 생성되면 풀에 쌓이고 작업이 대기열을 튱해 스레드별로 분배된다.  
모든 스레드가 바쁘면 대기열에 머무르며 스레드가 이용 가능할 때 까지 기다린다.