# 외부 연동이 문제일 때 살펴봐야 할 것들
A은행은 새로운 서비스 오픈을 앞두고 사용자 기대감을 높이고 있었고, 대규모 서비스 경험이 있는 개발팀이 있어 오픈 시점에 몰릴 트래픽 처리에도 자신감이 있었다. 하지만 A은행은 오픈과 동시에 장애를 겪었다.  
  
A은행은 가입 과정에서 필요한 정보 인증을 위해 외부 서비스를 호출했는데, 이 외부 서비스가 몰려드는 트래픽을 감당하지 못하면서 장애가 발생한 것이다.  
  
연동 서비스의 문제를 완전히 차단하기는 어렵다. 연동 서비스가 필수인 경우도 있기 때문이다. 하지만 그 영향은 줄일 수 있다.  
- 타임아웃과 재시도  
- 동시 요청 제한과 서킷브레이커  
- DB와 외부 연동  
- HTTP 커넥션 풀  
- 이중화  
## 타임아웃
연동 서비스를 호출할 때 타임아웃을 적절히 설정하지 않으면, 연동 서비스에 장애가 발생했을 때 전체 서비스의 품질이 급격히 나빠질 수 있다.  
```
A 서비스는 톰캣을 사용하고 있으며 스레드 풀 크기는 200이다. 즉, A서비스는 동시에 200개의 요청을 처리할 수 있다.  
A 서비스는 B 서비스를 호출한다.  
B 서비스에 성능 문제가 생겨 응답 시간이 60초를 넘기기 시작했다.  
```
200명이 A 서비스에 요청을 보내고, 200개의 요청이 동시에 처리되고 있고 모두 B 서비스의 응답을 기다리고 있다.  
10초 후, A 서비스에 새로운 100명이 요청을 보낸다. 하지만 A 서비스의 기존 200개 스레드는 아직 응답 대기 중이므로 새로 들어온 요청은 처리가 되지 않는다. A 서비스는 앞선 요청이 끝나야 새로운 요청을 처리할 수 있다. 그러나 B 서비스가 응답하지 않기 때문에 대기는 끝나지 않고 서비스는 마비된다.  
  
또한 사용자는 응답이 올 때 까지 기다리지 않는다. 새로 고침과 같은 방법으로 새로운 요청을 보낸다. -> 이는 문제를 더 악화시킨다. 사용자 입장에서는 앞서 보낸 요청을 취소한 것이지만 A 서비스는 그 사실을 바로 인지하지 못한다. 앞서 사용자가 보낸 요청을 여전히 처리 중이다. 이 상태에서 새로운 요청이 하나 더 들어오게 된다. 즉, 서버가 받는 부하가 배가 되는 상황이 발생한다.  
  
이런 문제를 완화할 수 있는 방법 중 하나는 연동에 대해 타임아웃을 지정하는 것이다.  
    
[Connection timeout, Read timeout](https://alden-kang.tistory.com/20)  
처음 연동하는 서비스라면 타임아웃 시간을 아래와 같이 설정한 뒤, 추이를 보면서 조정하는 것이 좋다.  
- 연결 타임아웃: 3초 ~ 5초  
- 읽기 타임아웃: 5초 ~ 30초  
  
읽기 타임아웃이 다소 길게 느껴질 수 있다. 하지만 처음부터 1~3초 정도로 짧게 설정하면 타임아웃 에러가 자주 발생할 수 있다. **게다가 타임아웃 시간이 너무 짧으면 연동 서비스가 정상 처리했음에도 불구하고 타임아웃 에러가 발생할 수 있다.** 각 흐름은 다음과 같다.  
1. 고객은 상품 결제를 커머스 서버에 요청한다.  
2. 커머스 서버는 승인 처리를 위해 PG 서버 API를 호출한다. 이때 읽기 타임아웃을 5초로 지정한다.  
3. PG 서버는 카드 결제를 위해 카드사 시스템과 통신을 시작한다. 카드사가 승인 처리하는데 5초 이상 걸린다.  
4. 커머스 서버는 PG 서버로부터 5초 동안 응답을 받지 못해 타임아웃 에러가 발생하며 상품 결제에 실패한다.  
5. 커머스 서버는 고객에게 실패 응답을 전송한다.  
6. 카드사 서버는 10초 만에 결제 승인에 성공하고 그 결과를 PG 서버에 응답한다.  
  
이 과정이 끝나면 고객은 카드로는 결제했지만 상품은 구매하지 못하는 불쾌한 상황에 빠진다. 결제처럼 민감한 기능은 타임아웃 시간을 약간 길게 설정해서 간헐적으로 연동 시간이 길어지더라도 정상적으로 처리할 수 있어야 한다.  
  
read timeout을 지정할 때는 실제로 설정하는 값이 무엇인지 확인해야 한다. Apache HttpClient는 소켓 타임아웃을 설정한다. 소켓 타임아웃은 네트워크 패킷 단위를 기준으로 하므로, 전체 응답 시간에 대한 타임아웃을 의미하지는 않는다. 따라서 소켓 타임아웃을 5초로 지정해도 전체 응답 시간은 5초 이상 걸릴 수 있다.  
  
## 재시도
네트워크 통신 과정에서 간헐적으로 연결에 실패하거나 일시적으로 응답이 느려지는 경우가 있다. 이럴 때는 재시도를 통해 연동 실패를 성공으로 바꿀 수 있다.  
  
항상 재시도를 할 수 있는 것은 아니다. 연동 API를 다시 호출해도 되는 조건인지 확인해야 한다. (포인트 차감 API 등과 같은 경우)  
  
재시도를 해도 되는 조건은 다음 3가지로 정리할 수 있다.  
- 단순 조회 기능  
- connection timeout(연동 서비스에 아직 연결되지 않은 상태)  
- 멱등성을 가진 변경 기능  
  
재시도할 떄는 다음 2가지를 결정해야 한다.  
- 재시도 횟수  
- 재시도 간격  
  
대부분의 경우 1~2번 정도의 재시도가 적당하다. 2번 재시도를 하면 총 3번 시도한 것이 되는데, 모두 실패했다면 간헐적인 오류보다는 다른 근본적인 문제일 가능성이 높다. 이 경우에는 다시 재시도해도 실패할 확률이 높다.  
  
여러 차례 재시도할 때는 재시도 간격을 점진적으로 늘려 연동 서버에 가해지는 부하를 일부 완화할 수 있다.  
  
## 동시 요청 제한
벌크헤드(Bulkhead): 동시 요청을 제한하는 방식. 각 구성 요소를 격리함으로써 한 구성 요소의 장애가 다른 구성 요소에 영향을 주지 않도록 하는 설계 패턴이다.  
  
1번의 경우 동시 요청 300개를 B 서비스로 전달하는데, B 서비스의 응답이 느려지면서 A 서비스의 응답도 함꼐 느려지고 A 서비스의 나머지 기능에도 영향을 주게 된다.  
2번의 경우 B 서비스와 연동하는 요청이 동시에 300개 들어올 때, 100개는 처리되고 나머지 200개는 바로 에러 응답을 받는다. B 서비스와 연동하는 기능은 오류가 발생하지만, B 서비스를 연동하지 않는 나머지 기능은 정상 동작할 수 있다.  
  
## 서킷브레이커
연동 서비스에 과부하가 발생해 응답을 제대로 주지 못하고 있는 상황이라고 하자. 연동 서비스가 정솽화되기 전까지는 요청을 보내도 계속 에러만 발생한다. 또한 읽기 타임아웃이 발생할 때까지 대기하느라 응답 시간도 길어질 것이다.  
  
B 서비스가 정상 상태가 아닐 때, A 서비스는 B 서비스에 요청을 보내지 않고 바로 에러를 응답하는 것이 낫다. 이렇게 하면 B 서비스의 문제가 A 서비스에 주는 영향(응답 시간 증가, 처리량 감소 등)을 줄일 수 있다.  
  
서킷 브레이커는 **닫힘**, **열림**, **반 열림** 3가지 상태를 갖는다.  
  
서킷 브레이커는 닫힘 상태로 시작한다. 닫힘 상태일 때는 모든 요청을 연동 서비스에 전달한다. 외부 연동 과정에서 오류가 발생하기 시작하면, 지정한 임계치를 초과했는지 확인한다. 실패 건수가 임계치를 초과하면 서킷브레이커는 열림 상태가 된다. 보통 임계치는 다음 조건 중 하나를 사용한다.  
  
- 시간 기준 오류 발생 비율: 예) 10초 동안 오류 비율이 50% 초과  
- 개수 기준 오류 발생 비율: 예) 100개 요청 중 오류 비율이 50% 초과  
  
열림 상태가 되면 연동 요청은 수행하지 않고, 바로 에러 응답을 리턴한다. 열림 상태는 지정된 시간 동안 유지된다.  
지정된 시간이 지나면 반 열림 상태로 전환된다. 반 열림 상태가 되면 일부 요청에 한해 연동을 시도한다. 일정 개수 또는 일정 시간 동안 반 열림 상태를 유지하며, 이 기간동안 연동에 성공하면 닫힘 상태로 복귀한다. 반대로 연동에 실패하면 다시 열림 상태로 전환되어 연동을 차단한다.  
  
## 외부 연동과 DB 연동
1. 외부 연동에 실패했을 때 트랜잭션을 롤백  
외부 연동에 실패했을 때 트랜잭션을 롤백하면, 변경한 데이터가 DB에 반영되지 않는다. 하지만 읽기 타임아웃이 발생해 트랜잭션을 롤백할 떄는, 외부 서비스가 실제로는 성공적으로 처리했을 가능성을 염두에 두어야 한다.  
  
트랜잭션을 롤백했는데 외부 서비스가 실제로는 성공했을 경우, 일정 주기로 두 시스템의 데이터가 일치하는지 확인하고 보정하는 방법이나 성공/취소 API를 호출하는 방식이 있다.  
  
2. 외부 연동은 성공했지만 DB 연동에 실패해 트랜잭션을 롤백  
외부 연동은 성공했지만 DB 연동에 실패해 트랜잭션을 롤백한 경우에는 취소 API를 호출해 외부 연동을 이전 상태로 되돌리는 것이 중요하다.  
취소 API가 없거나 취소에 실패할 수도 있기 때문에 데이터 일관성이 중요한 서비스라면 일정 주기로 데이터가 맞는지 비교하는 프로세스를 갖추는 것이 좋다.  