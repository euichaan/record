# 도커없이 컨테이너 만들기
kakao tech 유튜브에 올라온 도커 없이 컨테이너 만들기를 통해 컨테이너 개념에 대해 학습해보자.  
[이게 돼요? 도커 없이 컨테이너 만들기 / if(kakao)2022](https://www.youtube.com/watch?v=mSD88FuST80)  
도커는 컨테이너를 다루는 도구.  
  
## 도커를 왜 쓸까요?
서버 환경에 구애받지 않고 애플리케이션을 배포할 수 있을까?  
컨테이너는 애플리케이션을 감싸는 전용 환경을 제공하는 방법으로 이 문제를 해결한다.  
**애플리케이션 전용 환경** -> 애플리케이션 뿐만 아니라 애플리케이션이 사용하는 바이너리, 의존성 라이브러리 즉 서버에서 제공해주는 것들 까지 애플리케이션과 함께 패키징될 필요가 있다.  
  
서버 안에서 애플리케이션이 구동되는 환경 자체를 격리할 수 있어야 한다.  
애플리케이션을 실행하기 위해서는 자원이 할당이되고 할당된 자원에 대해 사용을 보장해야 한다.  
정리하자면 **패키징, 격리, 자원보장**을 통해 애플리케이션 전용 환경을 제공할 수 있다.  
  
컨테이너를 사용하려면 리눅스 운영체제가 필요하다.(리눅스 전용 기술이기 때문에) 도커가 컨테이너를 기동할 때 백그라운드로 리눅스 가상 머신을 기동해주기 때문이다. 그 다음으로 도커와 같은 컨테이너 관리 도구가 필요하다. 리눅스 + 런타임(컨테이너 관리 도구)  

정작 컨테이너를 잘 알고있는 사람은 없다.  
문제가 생기면 컨테이너 환경을 볼 수 밖에 없다.  
  
컨테이너: 격리하는 환경을 통칭해서 사용한다.  
  
## 컨테이너 맛보기
sudo -Es: 루트 권한으로 세로운 쉘을 실행할 수 있게 한다.  
-E: 환경 변수를 유지한다. 원래 사용자의 환경 변수를 새로운 쉘에서도 유지하도록 한다.  
-s: 지정된 쉘을 실행한다. 일반적으로 사용자의 로그인 쉘을 root 권한으로 실행한다.  

호스트의 루트 디렉토리와 컨테이너의 루트 디렉토리가 다르다. (즉, 다른 시스템이다.) 루트 파일 시스템도 다르다. 프로세스도 다르다. 네트워크도 다르다.  
따라서 호스트의 80 포트를 쓰고 있더라도 컨테이너에서 쓸 수 있겠다는 생각을 할 수 있다.  
## 컨테이너 파일 시스템
### 프로세스를 가두자
chroot(change root directory)는 루트 디렉토리 밖으로는 프로세스가 나갈 수 없다는 것에 착안.  
해당 프로세스는 지정된 디렉토리를 시스템의 루트 디렉토리로 인식하게 된다.  
`chroot myroot /bin/sh`  
chroot 명령어는 뒤의 실행할 명령어가 myroot 하위에 있다고 알고 실행한다. myroot 밑에 bin 디렉토리와 sh 프로그램을 복사해야 한다.  
  
`which sh`로 sh 명령어가 어디있는지 확인할 수 있다. `ldd /bin/sh` 명령어로 /bin/sh 실행 파일이 사용하는 모든 공유 라이브러리를 나열한다.  
  
chroot 를 요약을 하고 넘어가자면,  
- **경로에 모으고(패키징)**  
- **경로에 가둬서 실행(격리)**  
  
chroot 하여 ps 명령어를 실행하려면 어떻게 해야할까?(프로세스 조회 명령어)  
  
`umount /tmp/myroot/proc` 리눅스에서 특정 마운트 포인트를 마운트 해제하는 명령어.  
마운트는 파일 시스템을 특정 디렉토리 트리에 연결하는 작업을 의미한다. 이 과정을 통해 사용자는 물리적 장치(예: 하드 드라이브, USB 드라이브 등)에 접근할 수 있게 된다. 마운트되지 않은 장치의 파일 시스템은 사용자가 접근할 수 없다.  
예를 들어 /dev/sdal이라는 디스크 파티션을 /mnt 디렉토리에 마운트하면, /mnt를 통해 해당 파티션에 접근할 수 있다.  
```bash
mount /dev/sda1 /mnt
```
마운트된 파일 시스템을 마운트 해제하는 과정을 언마운트라고 한다. 이를 통해 시스템에서 더이상 해당 파일 시스템에 접근하지 않게 된다.  
```bash
umount /mnt
```
도커 컨테이너에서 마운트는 호스트 머신의 디렉토리 또는 파일을 컨테이너의 파일 시스템에 연결하는 작업을 의미한다.  
이를 통해 컨테이너는 호스트의 파일이나 디렉토리에 접근할 수 있다.  
### 탈옥을 막아보자
이미지로 chroot를 해보면 어떨까?  
`docker export $(docker create nginx) | tar -C nginx-root -xvf -`  
서브쉘에서 docker create nginx를 하면 nginx를 docker repository로부터 내려받아서 컨테이너를 생성만 해둔다. 그 생성된 컨테이너를 docker export 명령을 이용하면 압축 스트림으로 보내준다. 그것을 파이프로 받아서 nginx-root 에 압축을 푼다.  
  
docker 이미지를 pull 받은 다음에, chroot로 실행을 할 수 있었다.  
그런데 chroot에서 탈옥을 할 수 있다.  
```c
#include <sys/stat.h>
#include <unistd.h>
int main(void)
{
  mkdir(".out", 0755);
  chroot(".out");
  chdir("../../../../../");
  chroot(".");
  return execl("/bin/sh", "-i", NULL);
}
```
탈옥을 어떻게 막을 수 있을까?  
  
루트 파일시스템에 대해서 알아보자.  
- 최상위 파일시스템  
- 루트 디렉토리를 포함  
- 하위의 모든 파일시스템이 마운트  
  
루트 파일시스템을 피봇하면 호스트에 영향이 간다. 호스트에 영향을 주지 않으려면? 프로세스의 환경을 격리하는 "네임스페이스"를 개발한다.  
"마운트 환경" 격리만 고려한 것으로, 궁극적으로는 피봇 루트가 가능하게끔 하고 싶었던 것이다.(호스트에 영향을 주지 않고)  
  
루트 파일시스템 조차도 루트 디렉토리에 마운트되는 것이다.  
마운트는 **파일시스템을 루트 파일시스템의 하위 디렉토리로 부착하는 시스템 콜**이다.  
마운트 포인트: 부착 지점, 접근 지점  
  
최초의 네임스페이스로 마운트 네임스페이스가 개발되었다. 마운트 포인트를 격리한다. 마운트 네임스페이스를 unshare(격리)를 하게되면 부모 프로세스의 마운트 네임스페이스 정보. 즉 마운트 포인트 정보를 복사해서 자식 마운트 네임스페이스를 만든다. 이 상태에서 자식 마운트 네임스페이스(즉 컨테이너) 에서 마운트를 하면 컨테이너 안에서만 내용이 보이고 부모 프로세스가 속해 있는 호스트 상에서는 보이지 않는다. 이렇게 해서 피봇 pivot 루트를 할 수 있다.  
### 중복을 해결하자