# 도커없이 컨테이너 만들기
kakao tech 유튜브에 올라온 도커 없이 컨테이너 만들기를 통해 컨테이너 개념에 대해 학습해보자.  
[이게 돼요? 도커 없이 컨테이너 만들기 / if(kakao)2022](https://www.youtube.com/watch?v=mSD88FuST80)  
도커는 컨테이너를 다루는 도구.  
  
## 도커를 왜 쓸까요?
서버 환경에 구애받지 않고 애플리케이션을 배포할 수 있을까?  
컨테이너는 애플리케이션을 감싸는 전용 환경을 제공하는 방법으로 이 문제를 해결한다.  
**애플리케이션 전용 환경** -> 애플리케이션 뿐만 아니라 애플리케이션이 사용하는 바이너리, 의존성 라이브러리 즉 서버에서 제공해주는 것들 까지 애플리케이션과 함께 패키징될 필요가 있다.  
  
서버 안에서 애플리케이션이 구동되는 환경 자체를 격리할 수 있어야 한다.  
애플리케이션을 실행하기 위해서는 자원이 할당이되고 할당된 자원에 대해 사용을 보장해야 한다.  
정리하자면 **패키징, 격리, 자원보장**을 통해 애플리케이션 전용 환경을 제공할 수 있다.  
  
컨테이너를 사용하려면 리눅스 운영체제가 필요하다.(리눅스 전용 기술이기 때문에) 도커가 컨테이너를 기동할 때 백그라운드로 리눅스 가상 머신을 기동해주기 때문이다. 그 다음으로 도커와 같은 컨테이너 관리 도구가 필요하다. 리눅스 + 런타임(컨테이너 관리 도구)  

정작 컨테이너를 잘 알고있는 사람은 없다.  
문제가 생기면 컨테이너 환경을 볼 수 밖에 없다.  
  
컨테이너: 격리하는 환경을 통칭해서 사용한다.  
  
## 컨테이너 맛보기
sudo -Es: 루트 권한으로 세로운 쉘을 실행할 수 있게 한다.  
-E: 환경 변수를 유지한다. 원래 사용자의 환경 변수를 새로운 쉘에서도 유지하도록 한다.  
-s: 지정된 쉘을 실행한다. 일반적으로 사용자의 로그인 쉘을 root 권한으로 실행한다.  

호스트의 루트 디렉토리와 컨테이너의 루트 디렉토리가 다르다. (즉, 다른 시스템이다.) 루트 파일 시스템도 다르다. 프로세스도 다르다. 네트워크도 다르다.  
따라서 호스트의 80 포트를 쓰고 있더라도 컨테이너에서 쓸 수 있겠다는 생각을 할 수 있다.  
## 컨테이너 파일 시스템
### 프로세스를 가두자
chroot(change root directory)는 루트 디렉토리 밖으로는 프로세스가 나갈 수 없다는 것에 착안.  
해당 프로세스는 지정된 디렉토리를 시스템의 루트 디렉토리로 인식하게 된다.  
`chroot myroot /bin/sh`  
chroot 명령어는 뒤의 실행할 명령어가 myroot 하위에 있다고 알고 실행한다. myroot 밑에 bin 디렉토리와 sh 프로그램을 복사해야 한다.  
  
`which sh`로 sh 명령어가 어디있는지 확인할 수 있다. `ldd /bin/sh` 명령어로 /bin/sh 실행 파일이 사용하는 모든 공유 라이브러리를 나열한다.  
  
chroot 를 요약을 하고 넘어가자면,  
- **경로에 모으고(패키징)**  
- **경로에 가둬서 실행(격리)**  
  
chroot 하여 ps 명령어를 실행하려면 어떻게 해야할까?(프로세스 조회 명령어)  
  
`umount /tmp/myroot/proc` 리눅스에서 특정 마운트 포인트를 마운트 해제하는 명령어.  
마운트는 파일 시스템을 특정 디렉토리 트리에 연결하는 작업을 의미한다. 이 과정을 통해 사용자는 물리적 장치(예: 하드 드라이브, USB 드라이브 등)에 접근할 수 있게 된다. 마운트되지 않은 장치의 파일 시스템은 사용자가 접근할 수 없다.  
예를 들어 /dev/sdal이라는 디스크 파티션을 /mnt 디렉토리에 마운트하면, /mnt를 통해 해당 파티션에 접근할 수 있다.  
```bash
mount /dev/sda1 /mnt
```
마운트된 파일 시스템을 마운트 해제하는 과정을 언마운트라고 한다. 이를 통해 시스템에서 더이상 해당 파일 시스템에 접근하지 않게 된다.  
```bash
umount /mnt
```
도커 컨테이너에서 마운트는 호스트 머신의 디렉토리 또는 파일을 컨테이너의 파일 시스템에 연결하는 작업을 의미한다.  
이를 통해 컨테이너는 호스트의 파일이나 디렉토리에 접근할 수 있다.  
### 탈옥을 막아보자
이미지로 chroot를 해보면 어떨까?  
`docker export $(docker create nginx) | tar -C nginx-root -xvf -`  
서브쉘에서 docker create nginx를 하면 nginx를 docker repository로부터 내려받아서 컨테이너를 생성만 해둔다. 그 생성된 컨테이너를 docker export 명령을 이용하면 압축 스트림으로 보내준다. 그것을 파이프로 받아서 nginx-root 에 압축을 푼다.  
  
docker 이미지를 pull 받은 다음에, chroot로 실행을 할 수 있었다.  
그런데 chroot에서 탈옥을 할 수 있다.  
```c
#include <sys/stat.h>
#include <unistd.h>
int main(void)
{
  mkdir(".out", 0755);
  chroot(".out");
  chdir("../../../../../");
  chroot(".");
  return execl("/bin/sh", "-i", NULL);
}
```
탈옥을 어떻게 막을 수 있을까?  
  
```text
시스템이 부팅이 될 때 임시로 해당 시스템에 붙어있는 디스크 등 여러 장치들을 올려야 하는데 그때 부팅 파일시스템을 선언한다.  
부팅 파일시스템으로 장치들이 올라오면 루트 파일시스템으로 전환을 해줘야 하는데 그때 사용되는 명령어가 pivot_root 이다.
pivot_root 를 이용하면 컨테이너의 루트를 바꿀 수 있지 않을까 에서 출발했다.  

컨테이너 전용 파일시스템을 어떻게 구축해야 할까? 에 대한 고민.
```
  
루트 파일시스템에 대해서 알아보자.  
- 최상위 파일시스템  
- 루트 디렉토리를 포함  
- 하위의 모든 파일시스템이 마운트  
  
루트 파일시스템을 피봇(pivot_root)하면 호스트에 영향이 간다. 호스트에 영향을 주지 않으려면? **프로세스의 환경을 격리하는 "네임스페이스"를 개발한다.**  
"마운트 환경" 격리만 고려한 것으로, 궁극적으로는 피봇 루트가 가능하게끔 하고 싶었던 것이다.(호스트에 영향을 주지 않고)  
  
루트 파일시스템 조차도 루트 디렉토리에 마운트되는 것이다.  
마운트는 **파일시스템을 루트 파일시스템의 하위 디렉토리로 부착하는 시스템 콜**이다.  
마운트 포인트: 부착 지점, 접근 지점  
  
최초의 네임스페이스로 마운트 네임스페이스가 개발되었다. 마운트 포인트를 격리한다. 마운트 네임스페이스를 unshare(격리)를 하게되면 부모 프로세스의 마운트 네임스페이스 정보. 즉 마운트 포인트 정보를 복사해서 자식 마운트 네임스페이스를 만든다. 이 상태에서 자식 마운트 네임스페이스(즉 컨테이너) 에서 마운트를 하면 컨테이너 안에서만 내용이 보이고 부모 프로세스가 속해 있는 호스트 상에서는 보이지 않는다. 이렇게 해서 피봇 pivot 루트를 할 수 있다.  
  
마운트 네임스페이스에 복사를 하면 루트 디렉토리에는 호스트의 루트 파일시스템이 부착되어 있다. 기존 루트파일시스템을 부착할 디렉토리만 만들어 주면 pivot_root를 할 수 있다. 따라서 호스트에 영향이 없다.  
  
`unshare --mount /bin/sh`  
df -h 명령어를 이용해서 컨테이너와 호스트의 파일 시스템을 살펴보면 동일하다. 마운트 네임스페이스를 unshare 하면 부모 프로세스의 마운트 네임스페이스 정보를 복사해서 자식 네임스페이스를 만든다. 그렇기 때문에 처음에는 같다.  
  
호스트에 영향 없이 마운트 네임스페이스를 격리해서 pivot_root 를 할 수 있다.  
`pivot_root . put_old`는 .(현재 경로)가 루트가 되고, 기존 root 파일시스템은 put_old 에 부착하라고 알려준다.  
패키징으로 잘 모으고, 모은 내용으로 실행도 했는데..?   
### 중복을 해결하자
이미지 중복 문제와 비용 문제가 발생했다.  
오버레이 파일시스템으로 이미지 "중복 문제"를 해결할 수 있다.  
- 여러 이미지 레이어를 하나로 마운트  
- Lower 레이어는 ReadOnly  
- Upper 레이어는 Writable  
- CoW, copy-on-write (원본유지)  
  
Upper 레이어만 변경가능하다. Merged View 에서는 하위 Lower 레이어부터 상위 Lower 레이어의 내옹이 보인다.  
Lower 레이어에 있는 파일의 삭제나 수정이 필요하면, Upper 레이어에 쓰게 된다.  
  
이미지 저장소에는 우분투 이미지 레이어, nginx 이미지 레이어, 이런식으로 존재한다.  
컨테이너에는 각각 ubuntu, nginx, mysql, tomcat 레이어를 올리고 upper 레이어, merged 레이어를 올린다.  
  
오버레이 마운트를 다음과 같이 할 수 있다.  
```bash
mount -t overlay overlay -o
lowerdir=tools:myroot,upperdir=rootfs/container,workdir=rootfs/work
rootfs/merge
```
copy-on-write를 통해서 원본을 보장할 수 있다.  
pull 할 때 레이어 단위로 받는 것을 알 수 있다.  
  
그렇다면 탈옥, 중복 말고 다른 문제는 없을까?  
## 컨테이너 격리와 자원
### 컨테이너 격리
초기의 컨테이너는 "전용루트파일시스템"으로 충분하다고 생각했다. 그러나..  
- 컨테이너에서 호스트의 다른 프로세스들이 보인다.  
- 컨테이너에서 호스트의 포트를 사용한다.  
- 컨테이너에 루트 권한이 있다.  
  
네임스페이스 특징  
- 모든 프로세스는 타입별로 네임스페이스에 속한다.  
- 자식 프로세스는 부모의 네임스페이스를 상속한다.  
`unshare [옵션] [프로그램 [arguments ... ]]`  
  
네임스페이스 확인 방법은 다음과 같다.  
```bash
ls -al /proc/$$/ns
readlink /proc/$$/ns/mnt

lsns -p 1
lsns -t mnt -p 1
```
네임스페이스는 프로세스가 다른 프로세스로부터 격리된 독립된 환경에서 실행되도록 한다.  
마운트 네임스페이스는 리눅스 커널의 네임스페이스 기능 중 하나로, 프로세스 그룹마다 별도의 마운트 포인트 목록을 가질 수 있게 해준다. 이를 통해 각 프로세스 그룹은 다른 프로세스 그룹과 독립적으로 파일 시스템을 마운트하거나 언마운트 할 수 있다.  
  
PID 네임스페이스는 PID(Process ID) 넘버스페이스를 격리한다. 부모-자식 네임스페이스 중첩 구조이며, 부모 네임스페이스에서는 자식 네임스페이스가 다 보인다. 자식 네임스페이스는 부모의 PID와 본인의 PID 를 가지고 있다.  
PID 1번은 특수한 프로세스이다. init 프로세스이며 (커널이 생성) 특수한 기능이 있다.  
- 시그널 처리, 커널이 보낸 시그널을 자식 프로세스들에게 전파  
- 자식 프로세스에서 발생하는 좀비, 고아 프로세스를 처리한다.  
- 1번 프로세스가 죽으면 시스템이 패닉 상태가 된다.(reboot을 해야 한다.)  
  
컨테이너의 PID 1은 다음과 같다.  
- PID 네임스페이스는 unshare 할 때 fork 하여 자식 PID 네임스페이스의 pid 1로 실행  
- 시그널 처리  
- 좀비, 고아 프로세스 처리  
- 죽으면 컨테이너 종료  
  
새로운 PID 네임스페이스가 생성될 때, 프로세스를 분리하기 위해 `fork` 시스템 호출이 사용된다. `fork` 호출로 인해 생성된 자식 프로세스는 새로운 PID 네임스페이스 내에서 실행되며, 이 프로세스는 해당 네임스페이스에서 PID 1이 된다.  
시그널 처리와 좀비, 고아 프로세스 처리는 구현하는 사람이 만들어줘야 한다.  
  
proc 파일시스템은 메모리 기반의 가상파일시스템이며, 커널이 관리하는 시스템 정보를 제공한다.  
  
네트워크 네임스페이스는 네트워크를 호스트와 격리한다. 그리고 네트워크를 가상화(가상 인터페이스 장치를 사용할 수 있다)  
컨테이너 간의 통신을 실습해보자.  
  
일반계정이 루트권한을 가지고 docker를 기동할 수 있게 되면 패키지 인스톨이 쉽고, 시스템 리소스 이용에 제약이 없다.  
그러나 보안에 취약하다.  
  
user namespace에서는 컨테이너 안에서만 root라고 착각을 한다. 실질적으로 이 프로세스는 root 권한이 아니다. 컨테이너 내부의 자원에 대해서는 root인 걸로 착각하고 사용하지만 호스트 밖으로 나와서 활동을 하려고 했을 때 일반 계정으로 취급이 된다.  
  
부모 namespace와 자식 namespace 를 remap 방식으로 이 문제를 해결했다. 그러나 기본 설정으로 user namespace를 사용하지는 않는다.  
  
### 컨테이너 자원
Cgroups는 시스템 자원을 그룹화한 후 프로세스를 해당 그룹에 포함시킨다. 프로세스는 그룹에 정해진 리소스만큼만 사용을 하는 방식이다.  
- 자원 할당과 제어를 파일시스템으로 제공하며  
- Cgroup 네임스페이스로 격리할 수 있다.  
  



 