# 항목 1: @OneToMany 연관관계를 효과적으로 구성하는 방법
양방향 지연 @OneToMany 연관관계와 관련해 Author와 Book이라는 두 엔티티를 생각해보자. author의 행은 여러 book 행에 의해 참조될 수 있으며, author_id 열은 author 테이블의 기본키를 ㅊ마조하는 외래키를 통해 이 관계를 매핑한다. 저자 없이 도서는 존재할 수 없기 때문에 author가 부모 측이 되고 book은 자식 측이 된다. 이 @ManyToOne 연관관계는 외래키 열을 영속성 컨텍스트(1차 캐시)와 동기화하는 역할을 한다.  
  
일반적인 규칙으로 단방향 연관관계보다는 양방향을 사용하자.  
  
## 항상 부모 측에서 자식 측으로 전이를 사용
자식 측에서 부모 측으로의 전이는 코드 스멜이자 잘못된 관행이며 도메인 모델과 애플리케이션 설계를 다시 살펴봐야 할 명확한 신호다. 통상적으로 부모 측에서 자식 측으로만 전이를 지정한다.  
`@OneToMany(cascade = CascadeType.ALL)`  
  
부모 측에 설정되는 mappedBy 속성은 양방향 연관관계의 특성을 부여한다. 다시 말해 양방향 @OneToMany 연관관계에서 부모 측 @OneToMany에 mappedBy가 지정되고 mappedBy에 의해 참조되는 자식 측에 @ManyToOne이 지정된다. mappedBy를 통해 양방향 @OneToMany 연관관계가 @ManyToOne 자식 측 매핑을 미러링한다는 신호를 보내는 것이다. 이 경우 Author 엔티티에 다음과 같이 추가한다.  
`@OneToMany(cascade = CascadeType.ALL, mappedBy = "author")`  
  
## 부모 측에 orphanRemoval 지정
부모 측 orphanRemoval 지정은 더 이상 참조되지 않은 자식들의 삭제를 보장한다. 즉, orphanRemoval은 소유 객체로부터 참조 없이 존재할 수 없는 의존 객체를 정리하기에 유용하다.  
`@OneToMany(cascade = CascadeType.ALL, mappedBy = "author", orphanRemoval = true)`  
  
## 연관관계의 양측을 동기화 상태로 유지
부모 측 도우미(헬퍼) 메서드를 통해 어렵지 않게 연관관계의 양쪽 상태를 동기화 할 수 있다.  
연관관계의 양쪽을 동기화 상태로 유지하려 노력하지 않으면 엔티티 상태 전환으로 인해 예기치 않은 동작이 발생될 수 있다. 이를 위해 Author 엔티티에 다음과 같은 도우미 메서드를 추가한다.  
```java
public void addBook(Book book) {
        this.books.add(book);
        book.setAuthor(this);
    }

    public void removeBook(Book book) {
        book.setAuthor(null);
        this.books.remove(book);
    }

    public void removeBooks() {
        Iterator<Book> iterator = this.books.iterator();

        while (iterator.hasNext()) {
            Book book = iterator.next();
            book.setAuthor(null);
            iterator.remove();
        }
    }
```

## equals()와 hashCode() 오버라이딩
자동 생성된 데이터베이스 식별자의 경우 equals() 메서드는 동등성 검사를 수행하기 전에 식별자의 null 검사를 수행해야 하며, hashCode() 메서드는 상수 값을 반환해야 한다는 것이다.  
자식 측에서 재정의돼어야 하는데.. 라는 말이 나오는데, 클로드의 답변  
```
부분적으로 맞지만, 정확하게는 "자식 측에서 재정의해야 한다"보다는 "양쪽 모두 재정의하되, 특히 자식 측이 중요하다"가 더 정확해요.

private Set<Book> books = new HashSet<>();  // ⭐ Set 사용 시!
Set<Book>에 Book을 넣을 때 equals()/hashCode() 사용
```
[JPA Hibernate 프록시 제대로 알고 쓰기](https://tecoble.techcourse.co.kr/post/2022-10-17-jpa-hibernate-proxy/)  
JPA 구현체인 하이버네이트는 프록시 객체를 통해 지연 로딩을 구현하고 있다.  
지연 로딩을 구현하기 위해 프록시를 사용한다. 프록시는 실제 객체의 상속본이다. 실제 객체를 상속한 타입을 가지고 있다. 그리고 프록시 객체는 실제 객체에 대한 참조를 보관하여, 프록시 객체의 메서드를 호출했을 때 실제 객체의 메서드를 호출한다. 프록시 객체가 실제 객체의 상속본은 JPA 엔티티 생성의 중요한 규칙을 만들어내기도 했다.  
- 기본 생성자는 최소 protected 접근 제한자를 가져야 한다.  
- 엔티티 클래스는 final로 정의할 수 없다.  
  
기본 생성자가 private이면 프록시 생성 시 super를 호출할 수 없을 것이고, 엔티티를 final로 선언한다면 상속이 불가능하다.  
  
프록시 객체 초기화: 실제 객체의 메서드를 호출할 필요가 있을 때 데이터베이스를 조회해서 참조 값을 채우게 되는데, 이를 프록시 객체를 초기화한다고 한다. 단, 프록시가 실제 객체를 참조하게 되는 것이지 프록시가 실제 객체로 바뀌지는 않는다.  
  
준영속 상태의 프록시를 초기화 한다거나 OSIV 옵션이 꺼져 있는 상황에 트랜잭션 바깥에서 프록시를 초기화 하려 하는 경우 LazyInitializationException을 만날 수 있다.  
  
프록시의 equals를 재정의할 때는 instanceof와 getId를 사용할 것  
equals를 호출하는 순간 프롟기가 초기화되어 Team.class와 Team$HibernateProxy.class 를 비교하게 되어 false가 반환된다.  
프록시의 필드값은 모두 null이기 때문에 Objects.equals(id, team.id)는 id값과 null을 비교하게 되어 false가 반환되게 된다. 하지만 getId는 실제 id를 반환한다.  
  
프록시가 생성되면 영속성 컨텍스트는 프록시를 반환한다. 한 트랜잭션 내에서 최초 생성이 프록시로 된 엔티티는 이후 초기화 여부에 상관 없이 영속성 컨텍스트가 무조건 같은 프록시 객체를 반환해주게 된다.  
반대로 영속성 컨텍스트에 최초로 저장될 때 실제 엔티티로 저장될 경우, 이후로는 프록시가 아닌 실제 엔티티가 반환된다.  
  
영속성 컨텍스트의 특징인 `동일성 보장`을 만족하기 위함.  
## 연관관계 양측에서 지연 로딩 사용
## toString() 오버라이딩 방법에 주의
toString()을 재정의해야 하는 경우 엔티티가 데이터베이스로부터 로드될 때 가져오는 기본 속성만 포함해야 한다. 지연 속성이나 연관관계를 포함하게 되면 해당 데이터를 가져오는 별도 SQL문이 실행되거나 `LazyInitializationException`이 발생된다.  
  
영속성 컨텍스트가 닫힌 후에 지연 로딩을 시도할 때 발생하는 예외.  
    
---  
엔티티 삭제 처리. 특히 자식 엔티티 처리에 주의해야 한다. CascadeType.REMOVE와 orphanRemoval=true가 처리되는 동안 많은 SQL문이 생성될 수 있다. 이 경우 벌크(bulk) 처리를 사용하는 것이 일반적으로 상당히 많은 엔티티를 삭제하는 가장 좋은 방법이다.  
# 항목 2: 단방향 @OneToMany 연관관계를 피해야 하는 이유
양방향 지연 @OneToMany 연관관계와 관련된 Author와 Book 엔티티를 고려해보자. 자식 엔티티인 Book을 등록하려 하면 book 테이블에 하나의 SQL INSERT문이 트리거되고 자식 엔티티를 삭제하면 book 테이블에 하나의 SQL DELETE문이 트리거된다.  
  
단방향 @OneToMany 연관관계를 가정해보자.  
누락된 @ManyToOne 연관관계는 부모-자식 연관관계를 관리하기 위한 별도의 연결 테이블을 생성한다.  
  
이 책에서는 @JoinColumn을 사용하지 않는 경우와 사용하는 경우에 대해서 나눠서 이야기하고 있다.  
@JoinColumn을 사용하지 않았을 때 JPA가 중간 조인 테이블을 자동으로 생성한다.  
- INSERT 시 추가 쿼리 발생  
- delete/update 시 불필요한 delete + insert  
- 3 way JOIN으로 성능 저하  
  
조인 테이블은 순서한 관계 매핑 테이블이기 때문에, Hibernate는 컬렉션의 변경사항을 추적할 때 전체를 삭제하고 다시 삽입하는 전략을 사용한다.  
```SQL
-- 1. Book INSERT
INSERT INTO book (title) VALUES ('책4');

-- 2. 기존 관계 모두 삭제
DELETE FROM author_books WHERE author_id = 1;

-- 3. 전체 다시 삽입 (3개 + 새로운 것 1개)
INSERT INTO author_books (author_id, books_id) VALUES (1, 1);
INSERT INTO author_books (author_id, books_id) VALUES (1, 2);
INSERT INTO author_books (author_id, books_id) VALUES (1, 3);
INSERT INTO author_books (author_id, books_id) VALUES (1, 4);
```
book 1개를 추가할 때 6개의 쿼리 발생. (1 + 1 + n + 1 = n + 3) 개의 쿼리가 추가로 발생한다.  
@JoinColumn을 사용하면 @OneToMany 연관관계가 자식 테이블 외래키를 제어할 수 있음을 하이버네이트에 지시한다.
```SQL
Hibernate: 
    create table author (
        age integer,
        id bigint generated by default as identity,
        genre varchar(255),
        name varchar(255),
        primary key (id)
    )
Hibernate: 
    create table book (
        author_id bigint,
        id bigint generated by default as identity,
        isbn varchar(255),
        title varchar(255),
        primary key (id)
    )
Hibernate: 
    alter table if exists book 
       add constraint FKklnrv3weler2ftkweewlky958 
       foreign key (author_id) 
       references author
```
이 경우에 insert 시 하이버네이트는 author_id 값을 설정하고자 UPDATE를 호출한다. 이는 분명히 양방향 @OneToMany 연관관계와 비교해 성능 저하가 추가되는 것이다.  
  
마지막 도서를 삭제하면 author_id를 null로 설정해 저자로부터 도서 연관관계를 끊는다.  
그런 다음 orphanRemoval=true 덕분에 연관이 해제된 도서가 삭제된다. 그럼에도 이런 추가 UPDATE는 양방향 @OneToMany 연관관계에서는 필요하지 않다.  
  
**그러나, 단방향 @OneToMany + @JoinColumn을 써야할 상황이 있다.**    
이 경우 @JoinColumn(nullable=false, updatable=false)를 사용하면 Many가 save 될 때 FK를 같이 넣어줘서 update 쿼리가 추가로 나가지 않는다.  

일반적인 규칙으로 단방향 @OneToMany 연관관계는 양방향 @OneToMay 또는 단방향 @ManyToOne 연관관계보다 덜 효율적이다.  
  
테스트로 실험해 본 결과 실제 update 쿼리가 나가지 않음을 확인했다.  
```SQL
Hibernate: 
    insert 
    into
        author
        (age, genre, name, id) 
    values
        (?, ?, ?, default)
Hibernate: 
    insert 
    into
        book
        (author_id, isbn, title, id) 
    values
        (?, ?, ?, default)
```
# 항목 3: 단방향 @ManyToOne의 효율성
플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.  
  
플러시를 실행하면 구체적으로 다음과 같은 일이 일어난다.  
1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.  
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.  
  
영속성 컨텍스트를 플러시하는 방법  
- em.flush() 직접 호출  
- 트랜잭션 커밋 시 플러시가 자동 호출  
- JPQL 쿼리 실행 시 플러시가 자동 호출  
  
update 쿼리가 나가지 않은 이유는 @Transactional 테스트는 기본적으로 롤백을 하기 때문이다.  
`TransactionalTestExecutionListener`를 보면 다음과 같이 나와있다.  
```text
* <h3>Declarative Rollback and Commit Behavior</h3>
 * <p>By default, test transactions will be automatically <em>rolled back</em>
 * after completion of the test; however, transactional commit and rollback
 * behavior can be configured declaratively via the {@link Commit @Commit}
 * and {@link Rollback @Rollback} annotations at the class level and at the
 * method level.
```
단방향 @OneToMany 연관관계는 매우 효율적으고 양방향 @OneToMany 연관관계가 필요하지 않을 때 사용할 수 있다. 다시 말하자면 단방향 @OneToMany 연관관계 사용은 피하자.  
  
# 항목 6: CascadeType.REMOVE 및 orphanRemoval=true를 사용해 하위 엔티티 제거를 피해야 하는 이유와 시기
CascadeType.REMOVE와 orphanRemoval=true의 차이점을 빠르게 살펴보자.  
  
CascadeType.REMOVE  
- 부모 엔티티가 삭제되면 자식 엔티티도 삭제된다. (즉, 부모가 자식의 삭제 생명 주기를 관리한다.)  
- **부모 엔티티가 자식 엔티티와의 관계를 제거해도 자식 엔티티는 삭제하지 않고 그대로 남아있다.**  
  
orphanRemoval=true  
- 부모 엔티티가 삭제되면 자식 엔티티도 삭제된다.  
- **부모 엔티티가 자식 엔티티의 관계를 제거하면 자식은 고아로 취급되어 그대로 사라진다.**  
```
@OneToMany(mappedBy = "author", cascade = CascadeType.ALL, orphanRemoval = true)
private List<Book> books = new ArrayList<>();

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "author_id")
private Author author;
```
Author 엔티티 삭제는 연관된 Book 엔티티로 자동 전이된다. 이는 CascadeType.REMOVE 또는 orphanRemoval=true가 하나라도 설정돼 있으면 처리가 되는데, 두 설정이 중복된다는 것이다.  
```java
public void removeBook(Book book) {
    book.setAuthor(null);
    this.books.remove(book);
}
```
  
orphanRemoval=false가 지정되어 있으면 UPDATE문이 호출된다. orphanRemoval=true는 엔티티의 참조 없이는 존재하지 않아야 할 엔티티를 정리하는 데 유용하다.  
저자를 삭제하면 연관된 모든 도서가 삭제되는데, 이는 CascadeType.REMOVE를 포함한 CascadeType.ALL의 효과다. 그러나 연관된 도서를 삭제하기 전에 SELECT를 통해 영속성 컨텍스트에 먼저 로드되는데, 이미 영속성 컨텍스트에 존재한다면 따로 로드되진 않는다. managed 상태여야만 orphanRemoval=true와 cascadeType.REMOVE가 동작한다.  
  
하지만 두 가지 옵션 모두 많은 DELETE문을 유발하고 성능 저하는 커진다.  
  
애플리케이션이 산발적인 삭제를 호출하는 경우 CascadeType.REMOVE나 orphanRemoval=true를 함께 또는 따로 사용할 수 있다. 이 경우 낙관적 락을 사용할 수 있고, 엔티티 상태 전환을 관리하는 하이버네이트가 필요하다. 그러나 좀 더 효율적인 삭제 방법을 찾는다면? 벌크 처리를 통해 저자와 연관 도서를 삭제한다.  
  
- 자동화된 낙관적 잠금 메커니즘을 무시한다.(@Version을 더이상 사용할 수 없음)  
- 영속성 컨텍스트는 벌크 작업에 의해 수행된 수정 사항을 반영하고자 동기화되지 않기 때문에 유효하지 않은 콘텍스트를 가질 수 있다.  
- CascadeType.REMOVE 또는 orphanRemoval을 활용할 수 없다.  
  
두 번째 같은 경우 flushAutomatically=true 또는 clearAutomatically=true를 통해 영속성 컨텍스트 동기화 문제를 관리할 수 있다. 그러나 이 2가지 설정이 항상 필요하다고 결론 내지 말아야 한다. 사용 방법은 달성해야 할 목적에 따라 다르기 때문이다.  
  
[JPA에서 대량의 데이터를 삭제할때 주의해야할 점](https://jojoldu.tistory.com/235)  
```
Hibernate: 
    select
        c1_0.id,
        c1_0.name 
    from
        customer c1_0 
    where
        c1_0.id in (?, ?, ?)
Hibernate: 
    delete 
    from
        customer 
    where
        id=?
Hibernate: 
    delete 
    from
        customer 
    where
        id=?
Hibernate: 
    delete 
    from
        customer 
    where
        id=?
```
deleteByIdIn의 동작 과정  
- select where in.. 으로 조회  
- 1건씩 삭제  
- CascadeType.DELETE 으로 하위 엔티티와 관계가 맺어진 경우 하위 엔티티들도 1건씩 삭제가 진행된다.  
  
범위 조건의 삭제 쿼리를 생성하면 된다. 그러면 삭제 쿼리 한번으로 해결이 가능하다.  
그러나 이 방법은 '영속성 컨텍스트는 벌크 작업에 의해 수행된 수정 사항을 반영하고자 동기화되지 않기 때문에 유효하지 않은 콘텍스트를 가질 수 있다'라는 문제가 있다.  
  
일반 delete의 경우 select로 엔티티를 조회해서 영속성 컨텍스트에 로드하지만 범위 조건의 Bulk 연산은 영속성 컨텍스트를 무시한다. clearAutomatically = true나 flushAutomatically=true를 사용해서 영속성 컨텍스트 동기화 문제를 관리할 수 있다.